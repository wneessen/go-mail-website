[{"id":0,"href":"/zh/examples/","title":"Examples","parent":"欢迎使用 go-mail 文档","content":""},{"id":1,"href":"/zh/getting-started/","title":"Getting started","parent":"欢迎使用 go-mail 文档","content":""},{"id":2,"href":"/zh/reference/","title":"Reference","parent":"欢迎使用 go-mail 文档","content":""},{"id":3,"href":"/zh/getting-started/introduction/","title":"简介","parent":"Getting started","content":"这篇简短的教程向您展示了如何从安装到发送第一封邮件使用go-mail。\n要求 安装 发送您的第一封邮件 创建新消息 发送邮件 结论 完整示例代码 要求 go-mail需要一个工作的Go安装（版本1.16+）。从Go下载页面下载Go。\n安装 可以使用Go模块安装机制通过go get命令安装go-mail。\n要安装go-mail的最新版本，请进入您的项目文件夹，然后通过发出以下命令导入模块即可：\n1 $ go get github.com/wneessen/go-mail 发送您的第一封邮件 go-mail由两个主要组件组成。 Msg表示邮件消息，Client通过SMTP服务处理邮件传递。\n创建新消息 首先，让我们使用NewMsg()方法创建一个新的Msg，并分配一个发件人地址和一个收件人地址。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 package main import ( \u0026#34;github.com/wneessen/go-mail\u0026#34; \u0026#34;log\u0026#34; ) func main() { m := mail.NewMsg() if err := m.From(\u0026#34;toni.sender@example.com\u0026#34;); err != nil { log.Fatalf(\u0026#34;failed to set From address: %s\u0026#34;, err) } if err := m.To(\u0026#34;tina.recipient@example.com\u0026#34;); err != nil { log.Fatalf(\u0026#34;failed to set To address: %s\u0026#34;, err) } } 在这个小代码片段中，首先我们将go-mail导入我们的项目。请参见第4行中的import语句。接下来，我们在第9行中创建了一个新消息。第10和13行设置了发件人和收件人地址。由于go-mail确保您提供的是有效的邮件地址，因此我们返回一个error。这样我们就可以确保go-mail接受提供的地址，并且不会在以后引起问题。\n接下来，我们要为我们的邮件设置一个主题行，并填充邮件正文内容。\n1 2 m.Subject(\u0026#34;This is my first mail with go-mail!\u0026#34;) m.SetBodyString(mail.TypeTextPlain, \u0026#34;Do you like this mail? I certainly do!\u0026#34;) SetBodyString()的第一个参数是我们需要提供的内容类型。在我们的示例中，mail.TypeTextPlain基本上表示text/plain内容类型-表示纯文本邮件正文。\n发送邮件 现在我们已经准备好发送邮件消息了，让我们将其发送出去。为此，我们将使用Client，它处理SMTP传输。\n1 2 3 4 5 c, err := mail.NewClient(\u0026#34;smtp.example.com\u0026#34;, mail.WithPort(25), mail.WithSMTPAuth(mail.SMTPAuthPlain), mail.WithUsername(\u0026#34;my_username\u0026#34;), mail.WithPassword(\u0026#34;extremely_secret_pass\u0026#34;)) if err != nil { log.Fatalf(\u0026#34;failed to create mail client: %s\u0026#34;, err) } 在此示例中，我们使用主机名smtp.example.com连接到邮件服务器，并为Client提供了一些选项，例如我们要连接的端口，我们要使用SMTP PLAIN进行身份验证以及用户名和密码。\n最后，我们告诉客户端交付邮件。\n1 2 3 if err := c.DialAndSend(m); err != nil { log.Fatalf(\u0026#34;failed to send mail: %s\u0026#34;, err) } DialAndSend()方法负责建立连接并发送邮件。您也可以分别调用它们，但是我们不需要快速示例。\n结论 那很简单，不是吗？您成功地准备了一封邮件消息，并通过第三方邮件服务器将其发送给收件人。当然，go-mail可以做更多。查看详细文档以获取所有功能。\n完整示例代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 package main import ( \u0026#34;github.com/wneessen/go-mail\u0026#34; \u0026#34;log\u0026#34; ) func main() { m := mail.NewMsg() if err := m.From(\u0026#34;toni.sender@example.com\u0026#34;); err != nil { log.Fatalf(\u0026#34;failed to set From address: %s\u0026#34;, err) } if err := m.To(\u0026#34;tina.recipient@example.com\u0026#34;); err != nil { log.Fatalf(\u0026#34;failed to set To address: %s\u0026#34;, err) } m.Subject(\u0026#34;This is my first mail with go-mail!\u0026#34;) m.SetBodyString(mail.TypeTextPlain, \u0026#34;Do you like this mail? I certainly do!\u0026#34;) c, err := mail.NewClient(\u0026#34;smtp.example.com\u0026#34;, mail.WithPort(25), mail.WithSMTPAuth(mail.SMTPAuthPlain), mail.WithUsername(\u0026#34;my_username\u0026#34;), mail.WithPassword(\u0026#34;extremely_secret_pass\u0026#34;)) if err != nil { log.Fatalf(\u0026#34;failed to create mail client: %s\u0026#34;, err) } if err := c.DialAndSend(m); err != nil { log.Fatalf(\u0026#34;failed to send mail: %s\u0026#34;, err) } } "},{"id":4,"href":"/zh/community/","title":"Communities","parent":"欢迎使用 go-mail 文档","content":""},{"id":5,"href":"/zh/tags/","title":"Tags","parent":"欢迎使用 go-mail 文档","content":""},{"id":6,"href":"/zh/security/","title":"安全策略","parent":"欢迎使用 go-mail 文档","content":" 已知漏洞 尽管 go-mail 没有已知的安全漏洞，您仍然可以查看我们的 GitHub 项目的安全公告页面。\n报告漏洞 要报告 go-mail 中的（可能的）安全问题，请发送电子邮件至security@go-mail.dev或使用 Github 的私人报告功能。我们非常欢迎报告。即使您不确定您发现的特定问题是否属于安全问题，我们也很乐意听取详细信息，以便我们一起确定是否需要解决该问题。\n通常，您会在一天内甚至几个小时内收到答复。\n端到端加密 您可以将 OpenPGP/GPG 加密邮件发送到security@go-mail.dev地址。\nOpenPGP/GPG 公钥：\n-----BEGIN PGP PUBLIC KEY BLOCK----- xjMEY8RwPBYJKwYBBAHaRw8BAQdAiLsW7pv+CCMq5Ol0hbIB1HnJI97u3zJw Wslr7GJzgOzNK3NlY3VyaXR5QGdvLW1haWwuZGV2IDxzZWN1cml0eUBnby1t YWlsLmRldj7CjAQQFgoAPgUCY8RwPAQLCQcICRCgTBOxf8keAAMVCAoEFgAC AQIZAQIbAwIeARYhBAoWEB7Y0bE7zcIOuaBME7F/yR4AAAByugD9HabWXsyD aPIDrIS97OBA1OLltB4NPT5ba9whKRxTEmMBALBiB2ML4ZTrjLqI6UbGkhJq mWeMtvmU0chZT7WNBO0PzjgEY8RwPBIKKwYBBAGXVQEFAQEHQGDEccz6gvl5 t8cMMb/Dy2l0elRZL+Nd0gOhnbWMWlArAwEIB8J4BBgWCAAqBQJjxHA8CRCg TBOxf8keAAIbDBYhBAoWEB7Y0bE7zcIOuaBME7F/yR4AAADaMwD9EvEA3NSN NtdSaeL/euh6oRRiCjKzh5bIqZiQXqMlIOoBAJvPE2facs8MISwTtDoHW0sD WdOs3yBpGlGCs5WEqvQH=zn96 -----END PGP PUBLIC KEY BLOCK----- "},{"id":7,"href":"/zh/","title":"欢迎使用 go-mail 文档","parent":"","content":" go-mail 是一个易于使用的 Go 库，用于格式化和发送邮件。它使用惯用的 Go 风格，并遵循最佳实践和合理的默认值。该库仅依赖于 Go 标准库。\ngo-mail 的工作方式类似于编程式电子邮件客户端，并提供了许多您在 MUA 中考虑的标准方法和功能。\n开始使用 go-mail 特色亮点 仅依赖于标准库 go-mail 不需要任何第三方模块，仅运行在 Go 标准库上\n现代、惯用的 Go 我们使用现代和惯用的 Go 标准，遵循最先进的最佳实践和合理的默认值\n完整的 TLS 支持 go-mail 支持不同策略的隐式 STARTTLS，以及用于发送邮件服务器的显式 SSL/TLS 的连接\n上下文 我们利用 Go 上下文进行更好的控制流和超时/取消处理\nSMTP 认证 支持三种常见的 SMTP 认证机制（LOGIN、PLAIN、CRAM-MD5）以及自定义身份验证。\n邮件地址验证 go-mail 遵循 RFC5322 并验证提供的邮件地址\n常见邮件头支持 go-mail 提供了许多常见邮件头的生成器（Message-ID、Date、Bulk-Precedence、Priority 等）\n连接重用 您可以在同一 SMTP 连接上发送多个邮件\n附件/嵌入 来自不同来源（本地文件系统、io.Reader 或 embed.FS）的附件和内联嵌入的完全支持\n编码和内容类型 go-mail 支持不同的编码和内容类型\n中间件 第三方库的中间件支持，以便更改邮件消息以满足其需求\nSendmail 和文件存储 支持通过本地 sendmail 安装发送邮件消息以及输出到本地文件（例如作为磁盘上的 .eml 文件以在 MUA 中打开它们）\nMDN 和 DSN go-mail 提供了请求 MDN（RFC 8098）和 DSN（RFC 1891）的支持\n模板支持 支持 Go 的 html/template 和 text/template（作为消息正文、替代部分或附件/嵌入）\nDKIM 支持 通过 go-mail-middlware/dkim 中间件的 DKIM 签名支持\n调试日志记录 支持 SMTP 客户端将任何 SMTP 通信记录到 STDERR 以进行调试目的\n自定义交付错误 使用 SendError 类型，用户可以获取有关交付错误的详细信息，包括错误是否为临时性质\n支持 我们在 Discord 上有一个支持和一般讨论频道。找到我们：#go-mail\n"},{"id":8,"href":"/zh/reference/client/options/","title":"客户端选项","parent":"邮件发送客户端","content":" Option WithDebugLog() WithDSN() WithDSNMailReturnType() WithDSNRcptNotifyType() WithHELO() Option Signature 1 type Option func(*Client) error Option 是可选参数函数，可以用作 NewClient() 方法的可选参数，以覆盖返回的 Client 的默认值。\nWithDebugLog() Signature 1 func WithDebugLog() Option Example 1 2 3 4 5 6 7 8 9 10 package main import \u0026#34;github.com/wneessen/go-mail\u0026#34; func main() { c, err := mail.NewClient(\u0026#34;mail.example.com\u0026#34;, mail.WithDebugLog()) if err != nil { panic(err) } } Version Introduced in go-mail v0.3.9 WithDebugLog 启用 SMTP 流量的调试日志。启用后，客户端与服务器之间的任何 SMTP 通信都会记录到 os.Stderr。\n在输出中，C --\u0026gt; S 是客户端到服务器的通信，C \u0026lt;-- S 表示服务器到客户端的通信。\n以下是输出示例：\n2023/01/15 20:21:18 [DEBUG] C --\u0026gt; S: EHLO client.example.com 2023/01/15 20:21:18 [DEBUG] C \u0026lt;-- S: 250 server.example.com PIPELINING SIZE 152428800 ETRN STARTTLS AUTH LOGIN PLAIN AUTH=LOGIN PLAIN ENHANCEDSTATUSCODES 8BITMIME DSN 2023/01/15 20:21:18 [DEBUG] C --\u0026gt; S: STARTTLS 2023/01/15 20:21:18 [DEBUG] C \u0026lt;-- S: 220 2.0.0 Ready to start TLS 2023/01/15 20:21:18 [DEBUG] C --\u0026gt; S: EHLO client.example.com 2023/01/15 20:21:18 [DEBUG] C \u0026lt;-- S: 250 server.example.com PIPELINING SIZE 152428800 ETRN AUTH LOGIN PLAIN AUTH=LOGIN PLAIN ENHANCEDSTATUSCODES 8BITMIME DSN 2023/01/15 20:21:18 [DEBUG] C --\u0026gt; S: AUTH LOGIN 2023/01/15 20:21:18 [DEBUG] C \u0026lt;-- S: 334 VXNlcm5hbWU6 2023/01/15 20:21:18 [DEBUG] C --\u0026gt; S: 2023/01/15 20:21:20 [DEBUG] C \u0026lt;-- S: 535 5.7.8 Error: authentication failed: VXNlcm5hbWU6 WithDSN() Signature 1 func WithDSN() Option Example 1 2 3 4 5 6 7 8 9 10 package main import \u0026#34;github.com/wneessen/go-mail\u0026#34; func main() { c, err := mail.NewClient(\u0026#34;mail.example.com\u0026#34;, mail.WithDSN()) if err != nil { panic(err) } } WithDSN 选项函数告诉 Client 请求 DSN（如果服务器支持）如RFC 1891所述。\nDSN（传递状态通知）是 SMTP 协议的扩展，需要发送服务器支持。DSN 的 RFC 定义了不同的参数，我们已经实现了我们认为对 go-mail 最有意义的参数：\nMAIL FROM 命令的 RET 扩展，让用户指定 DSN 是否应包含发送邮件的全部内容（FULL）或仅包含邮件头（HDRS）。 NOTIFY 扩展允许用户为不同类型的允许情况请求 DSN：NEVER、SUCCESS、FAILURE 和 DELAY ENVID 和 ORCPT 目前不受支持，但可能会在以后的版本中跟进（如果您认为这很有用，请打开一个 issue）。\n默认情况下，WithDSN() 设置 FULL 的 Mail From Return Option 和 SUCCESS 和 FAILURE 的 Recipient Notify Options。如果您想使用其他 DSN 设置，请参阅 WithDSNMailReturnType 和 WithDSNRcptNotifyType 的文档。\nWithDSNMailReturnType() Signature 1 func WithDSNMailReturnType(DSNMailReturnOption) Option Example 1 2 3 4 5 6 7 8 9 10 package main import \u0026#34;github.com/wneessen/go-mail\u0026#34; func main() { c, err := mail.NewClient(\u0026#34;mail.example.com\u0026#34;, mail.WithDSNMailReturnType(mail.DSNMailReturnFull)) if err != nil { panic(err) } } WithDSNMailReturnType 启用 Client 请求 DSN，如RFC 1891所述，并将 MAIL FROM 返回选项类型设置为给定的 DSNMailReturnOption。\ngo-mail 已经内置了以下两种 DSNMailReturnOption 类型：\nDSNMailReturnHeadersOnly：请求仅返回邮件的头部。\n参见：RFC 1891，第5.3节 DSNMailReturnFull：请求在为此收件人发出“失败”的传递状态通知时返回整个消息。\n参见：RFC 1891，第5.3节 WithDSNRcptNotifyType() Signature 1 func WithDSNRcptNotifyType(...DSNRcptNotifyOption) Option Example 1 2 3 4 5 6 7 8 9 10 11 12 package main import \u0026#34;github.com/wneessen/go-mail\u0026#34; func main() { c, err := mail.NewClient(\u0026#34;mail.example.com\u0026#34;, mail.WithDSNRcptNotifyType(mail.DSNRcptNotifyFailure, mail.DSNRcptNotifyDelay, mail.DSNRcptNotifySuccess)) if err != nil { panic(err) } } WithDSNRcptNotifyType 启用 Client 请求 DSN，如RFC 1891所述，并将 RCPT TO 通知选项设置为给定的 DSNRcptNotifyOption 列表。\ngo-mail 已经内置了以下 DSNRcptNotifyOption 类型：\nDSNRcptNotifyNever：不要在任何情况下向发送方返回 DSN。\n参见：RFC 1891，第5.1节 DSNRcptNotifySuccess：请求在成功传递时发出 DSN\n参见：RFC 1891，第5.1节 DSNRcptNotifyFailure：请求在传递失败时发出 DSN\n参见：RFC 1891，第5.1节 DSNRcptNotifyDelay：表示发送方愿意接收“延迟”的 DSN。如果消息的传递已经被延迟了不寻常的时间（由消息被延迟的 MTA 确定），但无法确定最终的传递状态（无论成功还是失败），则可以发出延迟的 DSN。在 NOTIFY 参数中缺少 DELAY 关键字会要求在任何情况下都不发出“延迟”的 DSN。\n参见：RFC 1891，第5.1节 WithHELO() Signature 1 func WithHELO(string) Option Example 1 2 3 4 5 6 7 8 9 10 package main import \u0026#34;github.com/wneessen/go-mail\u0026#34; func main() { c, err := mail.NewClient(\u0026#34;mail.example.com\u0026#34;, mail.WithHELO(\u0026#34;test.example.com\u0026#34;)) if err != nil { panic(err) } } WithHELO 指示 Client 使用提供的字符串作为 HELO/EHLO 问候主机。默认情况下，Client 将使用 Go 的 os.Hostname() 方法获取本地主机名，并将其用于 HELO/EHLO 问候。WithHELO 将覆盖此设置。\n"},{"id":9,"href":"/zh/examples/bulk-mailer/","title":"批量邮件示例","parent":"Examples","content":"在这个示例中，我们创建了一个小型的批量邮件发送程序，可以将相同的邮件发送给更多的收件人。对于我们来说，重要的是直接在邮件中寻址收件人，因此我们将使用Go的html/template和text/template系统以及占位符。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 package main import ( \u0026#34;fmt\u0026#34; ht \u0026#34;html/template\u0026#34; \u0026#34;log\u0026#34; \u0026#34;math/rand\u0026#34; \u0026#34;os\u0026#34; tt \u0026#34;text/template\u0026#34; \u0026#34;time\u0026#34; \u0026#34;github.com/wneessen/go-mail\u0026#34; ) // User是一个简单的类型，允许我们设置名字，姓氏和邮件地址 type User struct { Firstname string Lastname string EmailAddr string } // 我们的发件人信息将用于FROM地址字段 const ( senderName = \u0026#34;ACME Inc.\u0026#34; senderAddr = \u0026#34;noreply@acme.com\u0026#34; ) const ( textBodyTemplate = `Hi {{.Firstname}}, we are writing your to let you know that this week we have an amazing offer for you. Using the coupon code \u0026#34;GOMAIL\u0026#34; you will get a 20% discount on all our products in our online shop. Check out our latest offer on https://acme.com and use your discount code today! Your marketing team at ACME Inc.` htmlBodyTemplate = `\u0026lt;p\u0026gt;Hi {{.Firstname}},\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;we are writing your to let you know that this week we have an amazing offer for you. Using the coupon code \u0026#34;\u0026lt;strong\u0026gt;GOMAIL\u0026lt;/strong\u0026gt;\u0026#34; you will get a 20% discount on all our products in our online shop.\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;Check out our latest offer on \u0026lt;a href=\u0026#34;https://acme.com\u0026#34; target=\u0026#34;_blank\u0026#34;\u0026gt;https://acme.com\u0026lt;/a\u0026gt; and use your discount code today!\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;Your marketing team\u0026lt;br /\u0026gt; \u0026amp;nbsp;\u0026amp;nbsp;at ACME Inc.\u0026lt;/p\u0026gt;` ) func main() { // 定义我们要发送邮件的用户列表 ul := []User{ {\u0026#34;Toni\u0026#34;, \u0026#34;Tester\u0026#34;, \u0026#34;toni.tester@example.com\u0026#34;}, {\u0026#34;Tina\u0026#34;, \u0026#34;Tester\u0026#34;, \u0026#34;tina.tester@example.com\u0026#34;}, {\u0026#34;John\u0026#34;, \u0026#34;Doe\u0026#34;, \u0026#34;john.doe@example.com\u0026#34;}, } // 准备不同的模板 ttpl, err := tt.New(\u0026#34;texttpl\u0026#34;).Parse(textBodyTemplate) if err != nil { log.Fatalf(\u0026#34;failed to parse text template: %s\u0026#34;, err) } htpl, err := ht.New(\u0026#34;htmltpl\u0026#34;).Parse(htmlBodyTemplate) if err != nil { log.Fatalf(\u0026#34;failed to parse text template: %s\u0026#34;, err) } var ms []*mail.Msg r := rand.New(rand.NewSource(time.Now().UnixNano())) for _, u := range ul { rn := r.Int31() m := mail.NewMsg() if err := m.EnvelopeFrom(fmt.Sprintf(\u0026#34;noreply+%d@acme.com\u0026#34;, rn)); err != nil { log.Fatalf(\u0026#34;failed to set ENVELOPE FROM address: %s\u0026#34;, err) } if err := m.FromFormat(senderName, senderAddr); err != nil { log.Fatalf(\u0026#34;failed to set formatted FROM address: %s\u0026#34;, err) } if err := m.AddToFormat(fmt.Sprintf(\u0026#34;%s %s\u0026#34;, u.Firstname, u.Lastname), u.EmailAddr); err != nil { log.Fatalf(\u0026#34;failed to set formatted TO address: %s\u0026#34;, err) } m.SetMessageID() m.SetDate() m.SetBulk() m.Subject(fmt.Sprintf(\u0026#34;%s, we have a great offer for you!\u0026#34;, u.Firstname)) if err := m.SetBodyHTMLTemplate(htpl, u); err != nil { log.Fatalf(\u0026#34;failed to set HTML template as HTML body: %s\u0026#34;, err) } if err := m.AddAlternativeTextTemplate(ttpl, u); err != nil { log.Fatalf(\u0026#34;failed to set text template as alternative body: %s\u0026#34;, err) } ms = append(ms, m) } // 通过SMTP发送邮件 c, err := mail.NewClient(\u0026#34;smtp.example.com\u0026#34;, mail.WithSMTPAuth(mail.SMTPAuthPlain), mail.WithTLSPolicy(mail.TLSMandatory), mail.WithUsername(os.Getenv(\u0026#34;SMTP_USER\u0026#34;)), mail.WithPassword(os.Getenv(\u0026#34;SMTP_PASS\u0026#34;)), ) if err := c.DialAndSend(ms...); err != nil { log.Fatalf(\u0026#34;failed to deliver mail: %s\u0026#34;, err) } log.Printf(\u0026#34;Bulk mailing successfully delivered.\u0026#34;) } "},{"id":10,"href":"/zh/community/guide/","title":"社区指南","parent":"Communities","content":"go-mail社区正在壮大，如果您正在阅读此文，那么您也想加入！\n资源 行为准则 支持和公告渠道 贡献 开发新功能 修复错误 测试 文档 翻译 支持 资源 行为准则 在我们的社区中，我们遵循我们的行为准则，并要求每个想要参与的人都要相应地行事。\n支持和公告渠道 Mastodon：在Mastodon上关注我们，以获取有关go-mail的最新消息 go-mail论坛：接收有关go-mail的公告并开始讨论。 Github问题：如果您要报告错误或请求功能，请使用GitHub问题。请遵守每个存储库的问题模板中指定的规则。 Discord：go-mail开发人员和用户在此处实时会面和聊天的地方。 贡献 go-mail是一个开源的、社区驱动的项目。我们欢迎任何人加入我们为项目做出贡献。本文档旨在帮助任何希望熟悉项目和开发流程的人。\n开发新功能 修复错误 测试 文档 翻译 支持 开发新功能 我们始终热衷于为go-mail添加新功能。添加新功能的过程如下：\n在Github的问题部分中检查带有“TODO”或“help wanted”标签的可用问题 如果没有找到打开的“TODO”/“help wanted”问题或您想要的功能未涵盖，请为该特定功能打开一个提案问题，并等待项目维护者的“OK” 开发之前，请检查问题是否包括以下信息： 增强的目的 增强范围之外的内容 如果问题不包括此信息，请随时向打开问题的人请求信息。有时会创建占位符问题并需要更多详细信息 在问题上发表评论，说明您希望开发该功能 克隆存储库并创建格式为feature/\u0026lt;issue_number\u0026gt;_\u0026lt;issue_title\u0026gt;的分支 新功能通常需要文档，因此请确保您还添加或更新了文档作为更改的一部分 请确保您的代码具有所需的测试覆盖范围 一旦功能准备好进行测试，请创建草案PR。请确保PR说明中列出了测试场景和测试用例，并带有复选框，以便其他人知道仍需测试什么 一旦所有测试都完成，请从草案中更新PR的状态并留言 未附带相应问题的任何PR可能会被拒绝。 修复错误 修复错误的过程如下：\n检查Github问题并选择要修复的错误 开发之前，请检查问题是否包括以下信息： 受影响的平台范围 重现步骤。有时会打开不是go-mail问题的错误，并且责任在于报告人证明它是具有最小可重现示例的go-mail问题 如果问题不包括此信息，请随时向打开问题的人请求信息 在问题上发表评论，说明您希望开发修复程序 克隆存储库并创建格式为bugfix/\u0026lt;issue_number\u0026gt;_\u0026lt;issue_title\u0026gt;的分支 一旦修复程序准备好进行测试，请创建草案PR。请确保PR说明中列出了测试场景和测试用例，并带有复选框，以便其他人知道仍需测试什么 一旦所有测试都完成，请从草案中更新PR的状态并留言。 没有任何阻止您打开问题并自己解决它，但请注意，所有错误修复都应该进行讨论，因为方法可能会产生意外的副作用。 未附带相应问题的任何PR可能会被拒绝。 测试 测试对于确保项目质量至关重要。有几种情况下，测试可以真正帮助项目：\n测试是否可以在本地系统上重现错误 测试PR以确保它们正常工作 如果您选择测试某人的错误报告是否可以在本地系统上重现，则可以在问题上添加评论，确认这一点，并附上测试程序的输出。\n要测试PR，请选择要测试的PR并检查PR说明中是否列出了测试场景。如果没有，请要求打开PR的人提供该列表。一旦确定了有效的测试场景，请在PR上报告您的发现。\n如果您需要更多的明确或帮助进行测试，请在Github论坛或Discord上提问。\n文档 虽然我们要求代码中有适当的GoDoc文档注释，但本网站旨在更深入地记录功能和项目本身的文档。\n由于文档很难，网站仍处于不完整状态，因此对此的任何贡献都将不胜感激。没有文档的功能被认为是“未完成”的项目，它与代码一样重要。\n该网站基于Hugo使用Geekdocs主题构建。它非常简单，基本上由Markdown文件组成。在网站的存储库中有有关如何在本地计算机上安装网站的说明。\n翻译 go-mail项目的默认文档是英文文档。我们使用“Crowdin”工具将其他语言的文档翻译并同步到网站上。您可以加入我们的项目并提交您的翻译以进行贡献。\n目前，唯一支持的第二种语言是德语，但我们也热衷于添加其他语言。请通过go-mail-website存储库中的Github问题请求它们。\n支持 为项目做出贡献的一个很好的方法是帮助那些遇到困难的人。这通常报告为问题或在#go-mail Discord频道上的消息。即使只是澄清问题，也可以真正帮助。有时，当问题得到讨论并得到解决时，我们会将其制作成指南，以帮助其他面临相同问题的人。\n"},{"id":11,"href":"/zh/reference/client/","title":"邮件发送客户端","parent":"Reference","content":"在 go-mail 中，Client 负责通过 SMTP 协议与远程邮件服务器进行邮件传递。\nNewClient() Client Close() DialAndSend() DialAndSendWithContext() NewClient() Signature 1 func NewClient(string, ...Option) (*Client, error) Example 1 2 3 4 5 6 7 8 9 10 package main import \u0026#34;github.com/wneessen/go-mail\u0026#34; func main() { c, err := mail.NewClient(\u0026#34;mail.example.com\u0026#34;) if err != nil { panic(err) } } 要创建新的 Client，您可以使用 NewClient() 方法。作为第一个参数，它需要发送 SMTP 服务器的主机名。您可以选择提供一系列 Option 函数。这些选项函数可用于覆盖 Client 的默认设置。\n有关所有可用选项的详细信息，请查看 Options 文档。\nClient Signature 1 2 3 type Client struct { // 包含过滤或未导出字段 } Close() Signature 1 func (*Client) Close() error Example 1 2 3 4 5 6 7 8 9 10 11 package main import \u0026#34;github.com/wneessen/go-mail\u0026#34; func main() { c, err := mail.NewClient(\u0026#34;mail.example.com\u0026#34;) if err != nil { panic(err) } defer c.Close() } Close() 关闭 Client 连接到的 SMTP 服务器的连接。如果 Client 没有活动连接或关闭连接失败，则返回 error。\nDialAndSend() Signature 1 func (*Client) DialAndSend(...*Msg) error Example 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 package main import \u0026#34;github.com/wneessen/go-mail\u0026#34; func main() { from := \u0026#34;Toni Tester \u0026lt;toni@example.com\u0026gt;\u0026#34; to := \u0026#34;Alice \u0026lt;alice@example.com\u0026gt;\u0026#34; server := \u0026#34;mail.example.com\u0026#34; m := mail.NewMsg() if err := m.From(from); err != nil { panic(err) } if err := m.To(to); err != nil { panic(err) } m.Subject(\u0026#34;This is a great subject\u0026#34;) c, err := mail.NewClient(server) if err != nil { panic(err) } if err := c.DialAndSend(m); err != nil { panic(err) } } DialAndSend() 方法是 DialAndSendWithContext() 的别名，使用默认的 context.Background 上下文。DialAndSend() 接受一个或多个 Msg 指针作为参数，并在执行任何操作失败时返回 error。\nDialAndSendWithContext() Signature 1 func (*Client) DialAndSendWithContext(context.Context, ...*Msg) error Example 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 package main import \u0026#34;github.com/wneessen/go-mail\u0026#34; func main() { from := \u0026#34;Toni Tester \u0026lt;toni@example.com\u0026gt;\u0026#34; to := \u0026#34;Alice \u0026lt;alice@example.com\u0026gt;\u0026#34; server := \u0026#34;mail.example.com\u0026#34; m := mail.NewMsg() if err := m.From(from); err != nil { panic(err) } if err := m.To(to); err != nil { panic(err) } m.Subject(\u0026#34;This is a great subject\u0026#34;) c, err := mail.NewClient(server) if err != nil { panic(err) } ctx := context.Background() if err := c.DialAndSendWithContext(ctx, m); err != nil { panic(err) } } DialAndSendWithContext() 是 Client 上的一站式快捷方法。一旦创建了 Client，调用 DialAndSendWithContext() 方法将使其连接到配置的服务器，发送给定的邮件 Msg，然后通过再次关闭连接来完成。\n该方法的第一个参数是 context.Context，后跟一个或多个 Msg 指针。DialAndSendWithContext() 在执行任何操作失败时返回 error。\n"}]