[{"id":0,"href":"/zh/examples/","title":"Examples","parent":"欢迎使用 go-mail 文档","content":""},{"id":1,"href":"/zh/getting-started/","title":"Getting started","parent":"欢迎使用 go-mail 文档","content":""},{"id":2,"href":"/zh/reference/","title":"Reference","parent":"欢迎使用 go-mail 文档","content":""},{"id":3,"href":"/zh/getting-started/introduction/","title":"简介","parent":"Getting started","content":"This short tutorial shows you how to get up and running with go-mail from installation to sending your first mail.\n要求 安装 发送您的第一封邮件 创建新消息 发送邮件 结论 完整示例代码 要求 go-mail requires a working Go installation (Version 1.16+). Download Go from the Go Downloads Page. 从Go下载页面下载Go。 从Go下载页面下载Go。\n安装 可以使用Go模块安装机制通过go get命令安装go-mail。\nTo install the latest version of go-mail, enter your project folder and simply import the module by issuing the following command:\n1 $ go get github.com/wneessen/go-mail 发送您的第一封邮件 go-mail由两个主要组件组成。 go-mail consists of two main components. The Msg which represents the mail message and the Client which takes care of the mail delivery via a SMTP service.\n创建新消息 First let\u0026rsquo;s create a new Msg using the NewMsg() method and assign a sender address as well as a recipient address.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 package main import ( \u0026#34;github.com/wneessen/go-mail\u0026#34; \u0026#34;log\u0026#34; ) func main() { m := mail.NewMsg() if err := m.From(\u0026#34;toni.sender@example.com\u0026#34;); err != nil { log.Fatalf(\u0026#34;failed to set From address: %s\u0026#34;, err) } if err := m.To(\u0026#34;tina.recipient@example.com\u0026#34;); err != nil { log.Fatalf(\u0026#34;failed to set To address: %s\u0026#34;, err) } } 在这个小代码片段中，首先我们将go-mail导入我们的项目。 请参见第4行中的import语句。 接下来，我们在第9行中创建了一个新消息。 第10和13行设置了发件人和收件人地址。 由于go-mail确保您提供的是有效的邮件地址，因此我们返回一个error。 这样我们就可以确保go-mail接受提供的地址，并且不会在以后引起问题。\n接下来，我们要为我们的邮件设置一个主题行，并填充邮件正文内容。\n1 2 m.Subject(\u0026#34;This is my first mail with go-mail!\u0026#34;) m.SetBodyString(mail.TypeTextPlain, \u0026#34;Do you like this mail? I certainly do!\u0026#34;) The first argument for SetBodyString() is a content type we need to provide. In our example the mail.TypeTextPlain basically represents a text/plain content type - meaning a plain text mail body. 在我们的示例中，mail.TypeTextPlain基本上表示text/plain内容类型-表示纯文本邮件正文。 在我们的示例中，mail.TypeTextPlain基本上表示text/plain内容类型-表示纯文本邮件正文。\n发送邮件 现在我们已经准备好发送邮件消息了，让我们将其发送出去。 Now that we have our mail message ready to go, let\u0026rsquo;s bring it on the way and send it out. For this we\u0026rsquo;ll use the Client, which handles the SMTP transmission.\n1 2 3 4 5 c, err := mail.NewClient(\u0026#34;smtp.example.com\u0026#34;, mail.WithPort(25), mail.WithSMTPAuth(mail.SMTPAuthPlain), mail.WithUsername(\u0026#34;my_username\u0026#34;), mail.WithPassword(\u0026#34;extremely_secret_pass\u0026#34;)) if err != nil { log.Fatalf(\u0026#34;failed to create mail client: %s\u0026#34;, err) } In this example we connect to the mail server with the hostname smtp.example.com and provide the Client with a couple of options like the port we want to connect to, the fact that we want to use SMTP PLAIN for authentication and the username and password.\n最后，我们告诉客户端交付邮件。\n1 2 3 if err := c.DialAndSend(m); err != nil { log.Fatalf(\u0026#34;failed to send mail: %s\u0026#34;, err) } The DialAndSend() method takes care of establishing the connection and sending out the mail. You have the option to call them separately as well, but we won\u0026rsquo;t need this for the quick example. 您也可以分别调用它们，但是我们不需要快速示例。 您也可以分别调用它们，但是我们不需要快速示例。\n结论 那很简单，不是吗？ 您成功地准备了一封邮件消息，并通过第三方邮件服务器将其发送给收件人。 当然，go-mail可以做更多。 查看详细文档以获取所有功能。\n完整示例代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 func main() { m := mail.NewMsg() if err := m.From(\u0026#34;toni.sender@example.com\u0026#34;); err != nil { log.Fatalf(\u0026#34;failed to set From address: %s\u0026#34;, err) } if err := m.To(\u0026#34;tina.recipient@example.com\u0026#34;); err != nil { log.Fatalf(\u0026#34;failed to set To address: %s\u0026#34;, err) } m.Subject(\u0026#34;This is my first mail with go-mail!\u0026#34;) m.SetBodyString(mail.TypeTextPlain, \u0026#34;Do you like this mail? I certainly do!\u0026#34;) c, err := mail.NewClient(\u0026#34;smtp.example.com\u0026#34;, mail.WithPort(25), mail.WithSMTPAuth(mail.SMTPAuthPlain), mail.WithUsername(\u0026#34;my_username\u0026#34;), mail.WithPassword(\u0026#34;extremely_secret_pass\u0026#34;)) if err != nil { log.Fatalf(\u0026#34;failed to create mail client: %s\u0026#34;, err) } if err := c.DialAndSend(m); err != nil { log.Fatalf(\u0026#34;failed to send mail: %s\u0026#34;, err) } } m.Subject(\u0026#34;This is my first mail with go-mail!\u0026#34;) m.SetBodyString(mail.TypeTextPlain, \u0026#34;Do you like this mail? I certainly do!\u0026#34;) I certainly do!\u0026#34;) c, err := mail.NewClient(\u0026#34;smtp.example.com\u0026#34;, mail.WithPort(25), mail.WithSMTPAuth(mail.SMTPAuthPlain), mail.WithUsername(\u0026#34;my_username\u0026#34;), mail.WithPassword(\u0026#34;extremely_secret_pass\u0026#34;)) if err != nil { log.Fatalf(\u0026#34;failed to create mail client: %s\u0026#34;, err) } if err := c.DialAndSend(m); err != nil { log.Fatalf(\u0026#34;failed to send mail: %s\u0026#34;, err) } } m.Subject(\u0026#34;This is my first mail with go-mail!\u0026#34;) m.SetBodyString(mail.TypeTextPlain, \u0026#34;Do you like this mail? I certainly do!\u0026#34;) I certainly do!\u0026#34;) func main() { m := mail.NewMsg() if err := m.From(\u0026#34;toni.sender@example.com\u0026#34;); err != nil { log.Fatalf(\u0026#34;failed to set From address: %s\u0026#34;, err) } if err := m.To(\u0026#34;tina.recipient@example.com\u0026#34;); err != nil { log.Fatalf(\u0026#34;failed to set To address: %s\u0026#34;, err) } m.Subject(\u0026#34;This is my first mail with go-mail!\u0026#34;) m.SetBodyString(mail.TypeTextPlain, \u0026#34;Do you like this mail? I certainly do!\u0026#34;) c, err := mail.NewClient(\u0026#34;smtp.example.com\u0026#34;, mail.WithPort(25), mail.WithSMTPAuth(mail.SMTPAuthPlain), mail.WithUsername(\u0026#34;my_username\u0026#34;), mail.WithPassword(\u0026#34;extremely_secret_pass\u0026#34;)) if err != nil { log.Fatalf(\u0026#34;failed to create mail client: %s\u0026#34;, err) } if err := c.DialAndSend(m); err != nil { log.Fatalf(\u0026#34;failed to send mail: %s\u0026#34;, err) } } m.Subject(\u0026#34;This is my first mail with go-mail!\u0026#34;) m.SetBodyString(mail.TypeTextPlain, \u0026#34;Do you like this mail? I certainly do!\u0026#34;) I certainly do!\u0026#34;) c, err := mail.NewClient(\u0026#34;smtp.example.com\u0026#34;, mail.WithPort(25), mail.WithSMTPAuth(mail.SMTPAuthPlain), mail.WithUsername(\u0026#34;my_username\u0026#34;), mail.WithPassword(\u0026#34;extremely_secret_pass\u0026#34;)) if err != nil { log.Fatalf(\u0026#34;failed to create mail client: %s\u0026#34;, err) } if err := c.DialAndSend(m); err != nil { log.Fatalf(\u0026#34;failed to send mail: %s\u0026#34;, err) } } m.Subject(\u0026#34;This is my first mail with go-mail!\u0026#34;) m.SetBodyString(mail.TypeTextPlain, \u0026#34;Do you like this mail? I certainly do!\u0026#34;) I certainly do!\u0026#34;) c, err := mail.NewClient(\u0026#34;smtp.example.com\u0026#34;, mail.WithPort(25), mail.WithSMTPAuth(mail.SMTPAuthPlain), mail.WithUsername(\u0026#34;my_username\u0026#34;), mail.WithPassword(\u0026#34;extremely_secret_pass\u0026#34;)) if err != nil { log.Fatalf(\u0026#34;failed to create mail client: %s\u0026#34;, err) } if err := c.DialAndSend(m); err != nil { log.Fatalf(\u0026#34;failed to send mail: %s\u0026#34;, err) } } "},{"id":4,"href":"/zh/community/","title":"Communities","parent":"欢迎使用 go-mail 文档","content":""},{"id":5,"href":"/zh/examples/simple-mailer/","title":"Simple Mailer Example","parent":"Examples","content":"This example is the most simple piece of code that is required to successfully send a mail with go-mail.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 package main import ( \u0026#34;log\u0026#34; \u0026#34;os\u0026#34; \u0026#34;github.com/wneessen/go-mail\u0026#34; ) func main() { msg := mail.NewMsg() if err := msg.From(\u0026#34;toni@tester.com\u0026#34;); err != nil { log.Fatalf(\u0026#34;failed to set FROM address: %s\u0026#34;, err) } if err := msg.To(\u0026#34;tina@recipient.org\u0026#34;); err != nil { log.Fatalf(\u0026#34;failed to set TO address: %s\u0026#34;, err) } msg.Subject(\u0026#34;This is my first test mail with go-mail!\u0026#34;) msg.SetBodyString(mail.TypeTextPlain, \u0026#34;This will be the content of the mail.\u0026#34;) // Deliver the mails via SMTP c, err := mail.NewClient(\u0026#34;smtp.example.com\u0026#34;, mail.WithSMTPAuth(mail.SMTPAuthPlain), mail.WithTLSPortPolicy(mail.TLSMandatory), mail.WithUsername(os.Getenv(\u0026#34;SMTP_USER\u0026#34;)), mail.WithPassword(os.Getenv(\u0026#34;SMTP_PASS\u0026#34;)), ) if err != nil { log.Fatalf(\u0026#34;failed to create new mail delivery client: %s\u0026#34;, err) } if err := c.DialAndSend(msg); err != nil { log.Fatalf(\u0026#34;failed to deliver mail: %s\u0026#34;, err) } log.Printf(\u0026#34;Test mail successfully delivered.\u0026#34;) } This example will send a very basic test mail from toni@tester.com to tina@recipient.org.\nFirst, in line 11, we create a new Msg. The Msg type holds everything that is required for your mail message. Think of it like a new mail within your mail user agent. The Msg type provides you with all of the methods that are required to prepare and format your mail message.\nIn line 12 thru 14 we set the sender address. In this case it\u0026rsquo;s toni@tester.com. Since go-mail is doing a lot of validation under the hood, it will make sure that the provided mail address is valid. Therefore we check the returned error. In line 15 thru 17 we do the same for the recipient address. The mail will be sent to tina@recipient.org.\nNext, in line 18 we set our subject for our mail message. Followed by setting a simple string as message body in line 19. The first argument for Msg.SetBodyString() is a MIME content type. In this case we use mail.TypeTextPlain for the mail body - so a simple plain/text mail body.\nNow that our simple mail message is prepared for delivery, we can create a Client. The Client in go-mail handles the connection to a mail server and everything related to it. In line 22 thru 25 we initialize a new Client type and give it some options. The first argument is the mail server we want to connect to. In our example it\u0026rsquo;s smtp.example.com. Then we tell the Client that we need to perform SMTP Auth via the PLAIN auth method. The mail.WithSMTPAuth(mail.SMTPAuthPlain) option handles this. With the mail.WithTLSPortPolicy(mail.TLSMandatory) option, we tell the Client that we require a TLS connection for sending our mail. We set it to mandatory mode, so that the Client will stop processing if it cannot accomplish a TLS secured connection. With the mail.WithUsername() and mail.WithPassword() options, we let the Client know what username and password to use for the SMTP auth. Lines 26-28 check if the Client invocation worked without errors.\nFinally, in line 29-32 we send out our mail message using our mail client with the Client.DialAndSend() method. We print out a brief message on success or throw an error in case the delivery failed.\n"},{"id":6,"href":"/zh/tags/","title":"Tags","parent":"欢迎使用 go-mail 文档","content":""},{"id":7,"href":"/zh/security/","title":"安全策略","parent":"欢迎使用 go-mail 文档","content":" 已知漏洞 Even though there is no known security vulnerability in go-mail, you can always check the security advisories page of our GitHub project.\n报告漏洞 To report (possible) security issues in go-mail, please either send a mail to security@go-mail.dev or use Github\u0026rsquo;s private reporting feature. Reports are always welcome. Even if you are not 100% certain that a specific issue you found counts as a security issue, we\u0026rsquo;d love to hear the details, so we can figure out together if the issue in question needds to be addressed. 我们非常欢迎报告。 我们非常欢迎报告。 即使您不确定您发现的特定问题是否属于安全问题，我们也很乐意听取详细信息，以便我们一起确定是否需要解决该问题。\n通常，您会在一天内甚至几个小时内收到答复。\n端到端加密 您可以将 OpenPGP/GPG 加密邮件发送到security@go-mail.dev地址。\nOpenPGP/GPG 公钥：\n-----BEGIN PGP PUBLIC KEY BLOCK----- xjMEY8RwPBYJKwYBBAHaRw8BAQdAiLsW7pv+CCMq5Ol0hbIB1HnJI97u3zJw Wslr7GJzgOzNK3NlY3VyaXR5QGdvLW1haWwuZGV2IDxzZWN1cml0eUBnby1t YWlsLmRldj7CjAQQFgoAPgUCY8RwPAQLCQcICRCgTBOxf8keAAMVCAoEFgAC AQIZAQIbAwIeARYhBAoWEB7Y0bE7zcIOuaBME7F/yR4AAAByugD9HabWXsyD aPIDrIS97OBA1OLltB4NPT5ba9whKRxTEmMBALBiB2ML4ZTrjLqI6UbGkhJq mWeMtvmU0chZT7WNBO0PzjgEY8RwPBIKKwYBBAGXVQEFAQEHQGDEccz6gvl5 t8cMMb/Dy2l0elRZL+Nd0gOhnbWMWlArAwEIB8J4BBgWCAAqBQJjxHA8CRCg TBOxf8keAAIbDBYhBAoWEB7Y0bE7zcIOuaBME7F/yR4AAADaMwD9EvEA3NSN NtdSaeL/euh6oRRiCjKzh5bIqZiQXqMlIOoBAJvPE2facs8MISwTtDoHW0sD WdOs3yBpGlGCs5WEqvQH=zn96 -----END PGP PUBLIC KEY BLOCK----- "},{"id":8,"href":"/zh/","title":"欢迎使用 go-mail 文档","parent":"","content":" go-mail is an easy to use Go library for formating and sending mails. It uses idiomatic Go style and follows best practice with sane defaults. The library only dependends on the Go Standard Library. 它使用惯用的 Go 风格，并遵循最佳实践和合理的默认值。 它使用惯用的 Go 风格，并遵循最佳实践和合理的默认值。 该库仅依赖于 Go 标准库。\ngo-mail works like a programatic email client and provides lots of methods and functionalities you would consider standard in a MUA.\n开始使用 go-mail 特色亮点 Standard Library dependant go-mail 不需要任何第三方模块，仅运行在 Go 标准库上\n现代、惯用的 Go We are using modern and idiotmatic Go standards with this library and follow state-of-the-art best practices with sane defaults\n完整的 TLS 支持 go-mail supports implicit STARTTLS with different policies as well as explicit SSL/TLS for connections to sending mail servers\n上下文 我们利用 Go 上下文进行更好的控制流和超时/取消处理\nSMTP 认证 Support for three common SMTP authentication mechanisms (LOGIN, PLAIN, CRAM-MD5) as well as custom authentications.\n邮件地址验证 go-mail 遵循 RFC5322 并验证提供的邮件地址\n常见邮件头支持 go-mail 提供了许多常见邮件头的生成器（Message-ID、Date、Bulk-Precedence、Priority 等）\n连接重用 您可以在同一 SMTP 连接上发送多个邮件\n附件/嵌入 来自不同来源（本地文件系统、io.Reader 或 embed.FS）的附件和内联嵌入的完全支持\n编码和内容类型 go-mail 支持不同的编码和内容类型\n中间件 第三方库的中间件支持，以便更改邮件消息以满足其需求\nSendmail 和文件存储 支持通过本地 sendmail 安装发送邮件消息以及输出到本地文件（例如作为磁盘上的 .eml 文件以在 MUA 中打开它们） as .eml files to disk to open them in a MUA) 支持通过本地 sendmail 安装发送邮件消息以及输出到本地文件（例如作为磁盘上的 .eml 文件以在 MUA 中打开它们） as .eml files to disk to open them in a MUA) as .eml files to disk to open them in a MUA)\nMDN 和 DSN go-mail 提供了请求 MDN（RFC 8098）和 DSN（RFC 1891）的支持\n模板支持 支持 Go 的 html/template 和 text/template（作为消息正文、替代部分或附件/嵌入）\nDKIM 支持 DKIM signature support via the go-mail-middlware/dkim middleware\n调试日志记录 支持 SMTP 客户端将任何 SMTP 通信记录到 STDERR 以进行调试目的\n自定义交付错误 With the SendError type the user is able to get detailed information about delivery errors including if the error is of temporary nature or not\n支持 We have a support and general discussion channel on Discord. Find us at: #go-mail We have a support and general discussion channel on Discord. Find us at: #go-mail 找到我们：#go-mail\n"},{"id":9,"href":"/zh/reference/client/options/","title":"客户端选项","parent":"邮件发送客户端","content":" Option WithDebugLog() WithDSN() WithDSNMailReturnType() WithDSNRcptNotifyType() WithHELO() Option Signature 1 type Option func(*Client) error Client Option are functions that can be used as optional arguments for the NewClient() methods to override the default vaules of the returned Client.\nWithDebugLog() Signature 1 func WithDebugLog() Option Example 1 2 3 4 5 6 7 8 9 10 package main import \u0026#34;github.com/wneessen/go-mail\u0026#34; func main() { c, err := mail.NewClient(\u0026#34;mail.example.com\u0026#34;, mail.WithDebugLog()) if err != nil { panic(err) } } Version Introduced in go-mail v0.3.9 WithDebugLog enables debug logging of SMTP traffic on the Client. When enabled, any SMTP communication from the client to the server and vice-versa is logged to os.Stderr. 启用后，客户端与服务器之间的任何 SMTP 通信都会记录到 os.Stderr。 启用后，客户端与服务器之间的任何 SMTP 通信都会记录到 os.Stderr。\nIn the output C --\u0026gt; S is the communication from the client to the server and C \u0026lt;-- S represents the communication back from the server to the client.\n以下是输出示例：\n2023/01/15 20:21:18 [DEBUG] C --\u0026gt; S: EHLO client.example.com 2023/01/15 20:21:18 [DEBUG] C \u0026lt;-- S: 250 server.example.com PIPELINING SIZE 152428800 ETRN STARTTLS AUTH LOGIN PLAIN AUTH=LOGIN PLAIN ENHANCEDSTATUSCODES 8BITMIME DSN 2023/01/15 20:21:18 [DEBUG] C --\u0026gt; S: STARTTLS 2023/01/15 20:21:18 [DEBUG] C \u0026lt;-- S: 220 2.0.0 Ready to start TLS 2023/01/15 20:21:18 [DEBUG] C --\u0026gt; S: EHLO client.example.com 2023/01/15 20:21:18 [DEBUG] C \u0026lt;-- S: 250 server.example.com PIPELINING SIZE 152428800 ETRN AUTH LOGIN PLAIN AUTH=LOGIN PLAIN ENHANCEDSTATUSCODES 8BITMIME DSN 2023/01/15 20:21:18 [DEBUG] C --\u0026gt; S: AUTH LOGIN 2023/01/15 20:21:18 [DEBUG] C \u0026lt;-- S: 334 VXNlcm5hbWU6 2023/01/15 20:21:18 [DEBUG] C --\u0026gt; S: 2023/01/15 20:21:20 [DEBUG] C \u0026lt;-- S: 535 5.7.8 Error: authentication failed: VXNlcm5hbWU6 WithDSN() Signature 1 func WithDSN() Option Example 1 2 3 4 5 6 7 8 9 10 package main import \u0026#34;github.com/wneessen/go-mail\u0026#34; func main() { c, err := mail.NewClient(\u0026#34;mail.example.com\u0026#34;, mail.WithDSN()) if err != nil { panic(err) } } The WithDSN option function tells the Client to request DSNs (if the server supports it) as described in RFC 1891.\nDSNs (Delivery Status Notification) are an extension to the SMTP protocol and need to be supported by the sending server. The RFC for DSNs defines different parameters of which we\u0026rsquo;ve implemented the once which we think make most sense for go-mail: DSNs (Delivery Status Notification) are an extension to the SMTP protocol and need to be supported by the sending server. The RFC for DSNs defines different parameters of which we\u0026rsquo;ve implemented the once which we think make most sense for go-mail: DSN 的 RFC 定义了不同的参数，我们已经实现了我们认为对 go-mail 最有意义的参数：\nThe RET extension for the MAIL FROM command, to let the user specify if a DSN should contain the full mail (FULL) or only headers (HDRS) of the sent mail. The NOTIFY extension that allows the user to request a DSN for the different types of allowed situations: NEVER, SUCCESS, FAILURE and DELAY ENVID and ORCPT are currently not supported but might follow in a later relaese (please open an issue if you see usefulness in this).\nBy default WithDSN() sets the FULL Mail From Return Option and the SUCCESS and FAILURE Recipient Notify Options. If you like to use other settings for the DSN, please see the documentation for WithDSNMailReturnType and WithDSNRcptNotifyType 如果您想使用其他 DSN 设置，请参阅 WithDSNMailReturnType 和 WithDSNRcptNotifyType 的文档。 如果您想使用其他 DSN 设置，请参阅 WithDSNMailReturnType 和 WithDSNRcptNotifyType 的文档。\nWithDSNMailReturnType() Signature 1 func WithDSNMailReturnType(DSNMailReturnOption) Option Example 1 2 3 4 5 6 7 8 9 10 package main import \u0026#34;github.com/wneessen/go-mail\u0026#34; func main() { c, err := mail.NewClient(\u0026#34;mail.example.com\u0026#34;, mail.WithDSNMailReturnType(mail.DSNMailReturnFull)) if err != nil { panic(err) } } WithDSNMailReturnType enables the Client to request DSNs (if the server supports it) as described in the RFC 1891 and set the MAIL FROM Return option type to the given DSNMailReturnOption\ngo-mail 已经内置了以下两种 DSNMailReturnOption 类型：\nDSNMailReturnHeadersOnly: requests that only the headers of the message be returned. See: RFC 1891, Section 5.3 参见：RFC 1891，第5.3节 参见：RFC 1891，第5.3节 DSNMailReturnFull: requests that the entire message be returned in any \u0026ldquo;failed\u0026rdquo; delivery status notification issued for this recipient See: RFC 1891, Section 5.3 WithDSNRcptNotifyType() Signature 1 func WithDSNRcptNotifyType(...DSNRcptNotifyOption) Option Example 1 2 3 4 5 6 7 8 9 10 11 12 package main import \u0026#34;github.com/wneessen/go-mail\u0026#34; func main() { c, err := mail.NewClient(\u0026#34;mail.example.com\u0026#34;, mail.WithDSNRcptNotifyType(mail.DSNRcptNotifyFailure, mail.DSNRcptNotifyDelay, mail.DSNRcptNotifySuccess)) if err != nil { panic(err) } } WithDSNRcptNotifyType enables the Client to request DSNs as described in RFC 1891 and sets the RCPT TO notify options to the given list of DSNRcptNotifyOption\ngo-mail 已经内置了以下 DSNRcptNotifyOption 类型：\nDSNRcptNotifyNever: requests that a DSN not be returned to the sender under any conditions. See: RFC 1891, Section 5.1 参见：RFC 1891，第5.1节 参见：RFC 1891，第5.1节 DSNRcptNotifySuccess：请求在成功传递时发出 DSN\n参见：RFC 1891，第5.1节 DSNRcptNotifyFailure：请求在传递失败时发出 DSN\n参见：RFC 1891，第5.1节 DSNRcptNotifyDelay: indicates the sender\u0026rsquo;s willingness to receive \u0026ldquo;delayed\u0026rdquo; DSNs. Delayed DSNs may be issued if delivery of a message has been delayed for an unusual amount of time (as determined by the MTA at which the message is delayed), but the final delivery status (whether successful or failure) cannot be determined. The absence of the DELAY keyword in a NOTIFY parameter requests that a \u0026ldquo;delayed\u0026rdquo; DSN NOT be issued under any conditions. See: RFC 1891, Section 5.1 如果消息的传递已经被延迟了不寻常的时间（由消息被延迟的 MTA 确定），但无法确定最终的传递状态（无论成功还是失败），则可以发出延迟的 DSN。 如果消息的传递已经被延迟了不寻常的时间（由消息被延迟的 MTA 确定），但无法确定最终的传递状态（无论成功还是失败），则可以发出延迟的 DSN。 在 NOTIFY 参数中缺少 DELAY 关键字会要求在任何情况下都不发出“延迟”的 DSN。 参见：RFC 1891，第5.1节 WithHELO() Signature 1 func WithHELO(string) Option Example 1 2 3 4 5 6 7 8 9 10 package main import \u0026#34;github.com/wneessen/go-mail\u0026#34; func main() { c, err := mail.NewClient(\u0026#34;mail.example.com\u0026#34;, mail.WithHELO(\u0026#34;test.example.com\u0026#34;)) if err != nil { panic(err) } } WithHELO 指示 Client 使用提供的字符串作为 HELO/EHLO 问候主机。 WithHELO instructs the Client to use the provided string as HELO/EHLO greeting host. By default the Client will use Go\u0026rsquo;s os.Hostname() method to get the local hostname and use that for the HELO/EHLO greeting. WithHELO will override this. WithHELO 将覆盖此设置。 WithHELO 将覆盖此设置。\n"},{"id":10,"href":"/zh/examples/bulk-mailer/","title":"批量邮件示例","parent":"Examples","content":"在这个示例中，我们创建了一个小型的批量邮件发送程序，可以将相同的邮件发送给更多的收件人。 In this example we create a small bulk mailer for sending out the same mail to a bigger list of recipients. It is important for us to address the recipient directly in the mail, therefore we will make use of Go\u0026rsquo;s html/template and text/template system together with placeholders.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 package main import ( \u0026#34;fmt\u0026#34; ht \u0026#34;html/template\u0026#34; \u0026#34;log\u0026#34; \u0026#34;math/rand\u0026#34; \u0026#34;os\u0026#34; tt \u0026#34;text/template\u0026#34; \u0026#34;time\u0026#34; \u0026#34;github.com/wneessen/go-mail\u0026#34; ) // User is a simple type allowing us to set a firstname, lastname and mail address type User struct { Firstname string Lastname string EmailAddr string } // Our sender information that will be used in the FROM address field const ( senderName = \u0026#34;ACME Inc.\u0026#34; senderAddr = \u0026#34;noreply@acme.com\u0026#34; ) const ( textBodyTemplate = `Hi {{.Firstname}}, we are writing your to let you know that this week we have an amazing offer for you. Using the coupon code \u0026#34;GOMAIL\u0026#34; you will get a 20% discount on all our products in our online shop. Check out our latest offer on https://acme.com and use your discount code today! Your marketing team at ACME Inc.` htmlBodyTemplate = `\u0026lt;p\u0026gt;Hi {{.Firstname}},\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;we are writing your to let you know that this week we have an amazing offer for you. package main import ( \u0026#34;fmt\u0026#34; ht \u0026#34;html/template\u0026#34; \u0026#34;log\u0026#34; \u0026#34;math/rand\u0026#34; \u0026#34;os\u0026#34; tt \u0026#34;text/template\u0026#34; \u0026#34;time\u0026#34; \u0026#34;github.com/wneessen/go-mail\u0026#34; ) // User is a simple type allowing us to set a firstname, lastname and mail address type User struct { Firstname string Lastname string EmailAddr string } // Our sender information that will be used in the FROM address field const ( senderName = \u0026#34;ACME Inc.\u0026#34; senderAddr = \u0026#34;noreply@acme.com\u0026#34; ) const ( textBodyTemplate = `Hi {{.Firstname}}, we are writing your to let you know that this week we have an amazing offer for you. Using the coupon code \u0026#34;GOMAIL\u0026#34; you will get a 20% discount on all our products in our online shop. Check out our latest offer on https://acme.com and use your discount code today! Your marketing team at ACME Inc.` htmlBodyTemplate = `\u0026lt;p\u0026gt;Hi {{.Firstname}},\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;we are writing your to let you know that this week we have an amazing offer for you. package main import ( \u0026#34;fmt\u0026#34; ht \u0026#34;html/template\u0026#34; \u0026#34;log\u0026#34; \u0026#34;math/rand\u0026#34; \u0026#34;os\u0026#34; tt \u0026#34;text/template\u0026#34; \u0026#34;time\u0026#34; \u0026#34;github.com/wneessen/go-mail\u0026#34; ) // User is a simple type allowing us to set a firstname, lastname and mail address type User struct { Firstname string Lastname string EmailAddr string } // Our sender information that will be used in the FROM address field const ( senderName = \u0026#34;ACME Inc.\u0026#34; senderAddr = \u0026#34;noreply@acme.com\u0026#34; ) const ( textBodyTemplate = `Hi {{.Firstname}}, we are writing your to let you know that this week we have an amazing offer for you. Using the coupon code \u0026#34;GOMAIL\u0026#34; you will get a 20% discount on all our products in our online shop. Check out our latest offer on https://acme.com and use your discount code today! Your marketing team at ACME Inc.` htmlBodyTemplate = `\u0026lt;p\u0026gt;Hi {{.Firstname}},\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;we are writing your to let you know that this week we have an amazing offer for you. Using the coupon code \u0026#34;\u0026lt;strong\u0026gt;GOMAIL\u0026lt;/strong\u0026gt;\u0026#34; you will get a 20% discount on all our products in our online shop.\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;Check out our latest offer on \u0026lt;a href=\u0026#34;https://acme.com\u0026#34; target=\u0026#34;_blank\u0026#34;\u0026gt;https://acme.com\u0026lt;/a\u0026gt; and use your discount code today!\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;Your marketing team\u0026lt;br /\u0026gt; \u0026amp;nbsp;\u0026amp;nbsp;at ACME Inc.\u0026lt;/p\u0026gt;` ) func main() { // Define a list of users we want to mail to ul := []User{ {\u0026#34;Toni\u0026#34;, \u0026#34;Tester\u0026#34;, \u0026#34;toni.tester@example.com\u0026#34;}, {\u0026#34;Tina\u0026#34;, \u0026#34;Tester\u0026#34;, \u0026#34;tina.tester@example.com\u0026#34;}, {\u0026#34;John\u0026#34;, \u0026#34;Doe\u0026#34;, \u0026#34;john.doe@example.com\u0026#34;}, } // Prepare the different templates ttpl, err := tt.New(\u0026#34;texttpl\u0026#34;).Parse(textBodyTemplate) if err != nil { log.Fatalf(\u0026#34;failed to parse text template: %s\u0026#34;, err) } htpl, err := ht.New(\u0026#34;htmltpl\u0026#34;).Parse(htmlBodyTemplate) if err != nil { log.Fatalf(\u0026#34;failed to parse text template: %s\u0026#34;, err) } var ms []*mail.Msg r := rand.New(rand.NewSource(time.Now().UnixNano())) for _, u := range ul { rn := r.Int31() m := mail.NewMsg() if err := m.EnvelopeFrom(fmt.Sprintf(\u0026#34;noreply+%d@acme.com\u0026#34;, rn)); err != nil { log.Fatalf(\u0026#34;failed to set ENVELOPE FROM address: %s\u0026#34;, err) } if err := m.FromFormat(senderName, senderAddr); err != nil { log.Fatalf(\u0026#34;failed to set formatted FROM address: %s\u0026#34;, err) } if err := m.AddToFormat(fmt.Sprintf(\u0026#34;%s %s\u0026#34;, u.Firstname, u.Lastname), u.EmailAddr); err != nil { log.Fatalf(\u0026#34;failed to set formatted TO address: %s\u0026#34;, err) } m.SetMessageID() m.SetDate() m.SetBulk() m.Subject(fmt.Sprintf(\u0026#34;%s, we have a great offer for you!\u0026#34;, u.Firstname)) if err := m.SetBodyHTMLTemplate(htpl, u); err != nil { log.Fatalf(\u0026#34;failed to set HTML template as HTML body: %s\u0026#34;, err) } if err := m.AddAlternativeTextTemplate(ttpl, u); err != nil { log.Fatalf(\u0026#34;failed to set text template as alternative body: %s\u0026#34;, err) } ms = append(ms, m) } // Deliver the mails via SMTP c, err := mail.NewClient(\u0026#34;smtp.example.com\u0026#34;, mail.WithSMTPAuth(mail.SMTPAuthPlain), mail.WithTLSPortPolicy(mail.TLSMandatory), mail.WithUsername(os.Getenv(\u0026#34;SMTP_USER\u0026#34;)), mail.WithPassword(os.Getenv(\u0026#34;SMTP_PASS\u0026#34;)), ) if err := c.DialAndSend(ms...); err != nil { log.Fatalf(\u0026#34;failed to deliver mail: %s\u0026#34;, err) } log.Printf(\u0026#34;Bulk mailing successfully delivered.\u0026#34;) } } } Let\u0026rsquo;s take the example apart to look at some details\u0026hellip;\nAt first, in line 15, we define a new type for our users that we want to address. This is totally optional and is only done so we can easily work with a list of users and address them later on in our text template. How you handle this, is totally up to you and not mandatory for this to work. This is totally optional and is only done so we can easily work with a list of users and address them later on in our text template. How you handle this, is totally up to you and not mandatory for this to work.\nIn line 28 thru 48 we set up a simple text and HTML template mail body with placeholders that can be used with Go\u0026rsquo;s html/template and text/template.\nNext we set up a list of users, we want to send our great bulk mailing to. Line 52 uses the User type for this. With the preparation work done, we will start looping over all of our users in line 70. For each user we create a new *mail.Msg. Line 52 uses the User type for this. With the preparation work done, we will start looping over all of our users in line 70. For each user we create a new *mail.Msg.\nFor bulk mailings it is common that the ENVELOPE FROM and the MAIL FROM differ, so that bounce mails are sent to some system that can mark those bounces in the local system as bounced. Therefore we set both of those from addresses in line 73 and line 76. The lines 79 to 85 should be of no surprise to you, if you already used go-mail before. Therefore we set both of those from addresses in line 73 and line 76. The lines 79 to 85 should be of no surprise to you, if you already used go-mail before.\nOne more interesting thing happens in lines 86 thru 91 in which we use our prepared html/template and text/template templates and apply it to our mail message using m.SetBodyHTMLTemplate and m.AddAlternativeTextTemplate. We provide the whole user struct as data to that methods, so that html/template and text/template can take care of replacing placeholders in the mail body. Go-mail will take care of all the bells and whistles with the template handling for you. With our mail message now complete, we append it to our mail message slice in line 93. We provide the whole user struct as data to that methods, so that html/template and text/template can take care of replacing placeholders in the mail body. Go-mail will take care of all the bells and whistles with the template handling for you. With our mail message now complete, we append it to our mail message slice in line 93. We provide the whole user struct as data to that methods, so that html/template and text/template can take care of replacing placeholders in the mail body. Go-mail will take care of all the bells and whistles with the template handling for you. With our mail message now complete, we append it to our mail message slice in line 93.\nFinally we create a new Client and send out all of our prepared messages in one go by providing the whole slice of messages to Client.DialAndSend.\n"},{"id":11,"href":"/zh/community/guide/","title":"社区指南","parent":"Communities","content":"go-mail社区正在壮大，如果您正在阅读此文，那么您也想加入！\n资源 行为准则 支持和公告渠道 贡献 开发新功能 修复错误 测试 文档 翻译 支持 资源 行为准则 In our community, we follow our Code of Conduct and ask everybody who likes to participate to act accordingly.\n支持和公告渠道 Mastodon：在Mastodon上关注我们，以获取有关go-mail的最新消息 go-mail forum: Receive announcements and start discussions about go-mail. Github issues: If you have a bug to report or feature to request, please use GitHub issues. Please respect the rules specified in each repository\u0026rsquo;s issue template. 请遵守每个存储库的问题模板中指定的规则。 请遵守每个存储库的问题模板中指定的规则。 Discord：go-mail开发人员和用户在此处实时会面和聊天的地方。 贡献 go-mail is an open source, community driven project. We welcome anyone to join us in contributing to the project. This documentation is aimed at anyone wishing to get familiar with the project and the development processes. 我们欢迎任何人加入我们为项目做出贡献。 我们欢迎任何人加入我们为项目做出贡献。 本文档旨在帮助任何希望熟悉项目和开发流程的人。\n开发新功能 修复错误 测试 文档 翻译 支持 开发新功能 We are always keen to add features to go-mail. The process for adding new features are as follows: 添加新功能的过程如下： 添加新功能的过程如下：\nCheck the issue section on Github for available issues with the \u0026ldquo;TODO\u0026rdquo; or \u0026ldquo;help wanted\u0026rdquo; tag If no open \u0026ldquo;TODO\u0026rdquo;/\u0026ldquo;help wanted\u0026rdquo; issue is found or the feature you have in mind is not covered, please open a proposal issue for that specific feature and wait for the \u0026ldquo;OK\u0026rdquo; from the project maintainers 开发之前，请检查问题是否包括以下信息： 增强的目的 增强范围之外的内容 If the issue does not include this information, feel free to request the information from the person who opened the issue. Sometimes placeholder issues are created and require more details 有时会创建占位符问题并需要更多详细信息 有时会创建占位符问题并需要更多详细信息 在问题上发表评论，说明您希望开发该功能 克隆存储库并创建格式为feature/\u0026lt;issue_number\u0026gt;_\u0026lt;issue_title\u0026gt;的分支 New features often require documentation so please ensure you have also added or updated the documentation as part of the changes 请确保您的代码具有所需的测试覆盖范围 一旦功能准备好进行测试，请创建草案PR。 请确保PR说明中列出了测试场景和测试用例，并带有复选框，以便其他人知道仍需测试什么 一旦所有测试都完成，请从草案中更新PR的状态并留言 未附带相应问题的任何PR可能会被拒绝。 修复错误 修复错误的过程如下：\n检查Github问题并选择要修复的错误 开发之前，请检查问题是否包括以下信息： 受影响的平台范围 重现步骤。 The steps to reproduce. Sometimes bugs are opened that are not go-mail issues and the onus is on the reporter to prove that it is a go-mail issue with a minimal reproducible example If the issue does not include this information, feel free to request the information from the person who opened the issue 在问题上发表评论，说明您希望开发修复程序 克隆存储库并创建格式为bugfix/\u0026lt;issue_number\u0026gt;_\u0026lt;issue_title\u0026gt;的分支 Once the fix is ready for testing, create a draft PR. Please ensure the PR description has the test scenarios and test cases listed with checkmarks, so that others can know what still needs to be tested Once the fix is ready for testing, create a draft PR. Please ensure the PR description has the test scenarios and test cases listed with checkmarks, so that others can know what still needs to be tested Once the feature is ready for testing, create a draft PR. Please ensure the PR description has the test scenarios and test cases listed with checkmarks, so that others can know what still needs to be tested 一旦所有测试都完成，请从草案中更新PR的状态并留言。 There is nothing stopping you from opening a issue and working on it yourself, but please be aware that all bugfixes should be discussed as the approach may have unintended side effects. 未附带相应问题的任何PR可能会被拒绝。 测试 测试对于确保项目质量至关重要。 Testing is vitally important to ensure quality in the project. There are a couple of scenarios where testing can really help the project:\n测试是否可以在本地系统上重现错误 测试PR以确保它们正常工作 If you chose to test if someone\u0026rsquo;s bug report is reproducible on your local system, then feel free to add a comment on the issue confirming this with the output of your test program.\nTo test PRs, choose a PR to test and check if the PR description has the testing scenarios listed. If not, please ask the person who opened the PR to provide that list. Once you have determined a valid test scenario, please report your findings on the PR. 如果没有，请要求打开PR的人提供该列表。 一旦确定了有效的测试场景，请在PR上报告您的发现。\nIf you ever need more clarity or help on testing, please ask a question in the Github forum or on Discord.\n文档 While we require proper GoDoc documenation comments in the code, this website is meant as more in-depth documenation of features and the project itself.\nSince documenattion is hard and the website is still in an incomplete state, any contribution to this is greatly appreciated. Features without documentation are condidered \u0026ldquo;unfinished\u0026rdquo; to the project, it\u0026rsquo;s as important as the code. Since documenattion is hard and the website is still in an incomplete state, any contribution to this is greatly appreciated. Features without documentation are condidered \u0026ldquo;unfinished\u0026rdquo; to the project, it\u0026rsquo;s as important as the code. 没有文档的功能被认为是“未完成”的项目，它与代码一样重要。\n该网站基于Hugo使用Geekdocs主题构建。 它非常简单，基本上由Markdown文件组成。 The website is built on Hugo using the Geekdocs theme. It\u0026rsquo;s very simple and basically consists of markdown files. There are instructions on how to install the website on your local computer in the website\u0026rsquo;s repository.\n翻译 The default documents of the go-mail project are English documents. We use the \u0026ldquo;Crowdin\u0026rdquo; tool to translate documents in other languages and synchronize them to the website. You can join our project and submit your translations to make contributions. 我们使用“Crowdin”工具将其他语言的文档翻译并同步到网站上。 您可以加入我们的项目并提交您的翻译以进行贡献。\nCurrently the only supported 2nd language is German, but we are keen to add other languages as well. Please request them via a Github issue in the go-mail-website repository. 请通过go-mail-website存储库中的Github问题请求它们。 请通过go-mail-website存储库中的Github问题请求它们。\n支持 为项目做出贡献的一个很好的方法是帮助那些遇到困难的人。 这通常报告为问题或在#go-mail Discord频道上的消息。 即使只是澄清问题，也可以真正帮助。 有时，当问题得到讨论并得到解决时，我们会将其制作成指南，以帮助其他面临相同问题的人。\n"},{"id":12,"href":"/zh/reference/client/","title":"邮件发送客户端","parent":"Reference","content":"In go-mail the Client is responsible for the mail delivery with remote mail servers that communicate via the SMTP protocol.\nNewClient() Client Close() DialAndSend() DialAndSendWithContext() NewClient() Signature 1 func NewClient(string, ...Option) (*Client, error) Example 1 2 3 4 5 6 7 8 9 10 package main import \u0026#34;github.com/wneessen/go-mail\u0026#34; func main() { c, err := mail.NewClient(\u0026#34;mail.example.com\u0026#34;) if err != nil { panic(err) } } 要创建新的 Client，您可以使用 NewClient() 方法。 作为第一个参数，它需要发送 SMTP 服务器的主机名。 您可以选择提供一系列 Option 函数。 这些选项函数可用于覆盖 Client 的默认设置。\n有关所有可用选项的详细信息，请查看 Options 文档。\nClient Signature 1 2 3 type Client struct { // 包含过滤或未导出字段 } Close() Signature 1 func (*Client) Close() error Example 1 2 3 4 5 6 7 8 9 10 11 package main import \u0026#34;github.com/wneessen/go-mail\u0026#34; func main() { c, err := mail.NewClient(\u0026#34;mail.example.com\u0026#34;) if err != nil { panic(err) } defer c.Close() } Close() closes the connection to the SMTP server the Client is connected to. It returns an error in case the Client has no active connection or if closing the connection fails. 如果 Client 没有活动连接或关闭连接失败，则返回 error。 如果 Client 没有活动连接或关闭连接失败，则返回 error。\nDialAndSend() Signature 1 func (*Client) DialAndSend(...*Msg) error Example 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 package main import \u0026#34;github.com/wneessen/go-mail\u0026#34; func main() { from := \u0026#34;Toni Tester \u0026lt;toni@example.com\u0026gt;\u0026#34; to := \u0026#34;Alice \u0026lt;alice@example.com\u0026gt;\u0026#34; server := \u0026#34;mail.example.com\u0026#34; m := mail.NewMsg() if err := m.From(from); err != nil { panic(err) } if err := m.To(to); err != nil { panic(err) } m.Subject(\u0026#34;This is a great subject\u0026#34;) c, err := mail.NewClient(server) if err != nil { panic(err) } if err := c.DialAndSend(m); err != nil { panic(err) } } The DialAndSend() method is an alias for DialAndSendWithContext() with a default context.Background context. DialAndSend() takes a list of Msg pointer as argument(s) and returns an error in case any of the performed actions fails. DialAndSend() 接受一个或多个 Msg 指针作为参数，并在执行任何操作失败时返回 error。 DialAndSend() 接受一个或多个 Msg 指针作为参数，并在执行任何操作失败时返回 error。\nDialAndSendWithContext() Signature 1 func (*Client) DialAndSendWithContext(context.Context, ...*Msg) error Example 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 package main import \u0026#34;github.com/wneessen/go-mail\u0026#34; func main() { from := \u0026#34;Toni Tester \u0026lt;toni@example.com\u0026gt;\u0026#34; to := \u0026#34;Alice \u0026lt;alice@example.com\u0026gt;\u0026#34; server := \u0026#34;mail.example.com\u0026#34; m := mail.NewMsg() if err := m.From(from); err != nil { panic(err) } if err := m.To(to); err != nil { panic(err) } m.Subject(\u0026#34;This is a great subject\u0026#34;) c, err := mail.NewClient(server) if err != nil { panic(err) } ctx := context.Background() if err := c.DialAndSendWithContext(ctx, m); err != nil { panic(err) } } DialAndSendWithContext() 是 Client 上的一站式快捷方法。 The DialAndSendWithContext() is a one-for-all shortcut method on the Client. Once the Client is created, calling the DialAndSendWithContext() method will have it connect to the configured server, send out the given mail Msg and finalize by closing the connection again.\nThe first argument of the method is a context.Context followed by a list of one or more Msg pointers. DialAndSendWithContext() does return an error in case any of the performed actions fails. The first argument of the method is a context.Context followed by a list of one or more Msg pointers. DialAndSendWithContext() does return an error in case any of the performed actions fails. DialAndSendWithContext() 在执行任何操作失败时返回 error。\n"}]