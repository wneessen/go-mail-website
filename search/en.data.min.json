[{"id":0,"href":"/examples/","title":"Examples","parent":"Welcome to the go-mail documentation","content":""},{"id":1,"href":"/getting-started/","title":"Getting started","parent":"Welcome to the go-mail documentation","content":""},{"id":2,"href":"/getting-started/introduction/","title":"Introduction","parent":"Getting started","content":"This short tutorial shows you how to get up and running with go-mail from installation to sending your first mail.\nRequirements Installation Sending your first mail Create a new message Sending the mail Conclusion Full example code Requirements go-mail requires a working Go installation (Version 1.16+). Download Go from the Go Downloads Page.\nInstallation go-mail can be installed using the Go module installation mechanism via the go get command.\nTo install the latest version of go-mail, enter your project folder and simply import the module by issuing the following command:\n1 $ go get github.com/wneessen/go-mail Sending your first mail go-mail consists of two main components. The Msg which represents the mail message and the Client which takes care of the mail delivery via a SMTP service.\nCreate a new message First let\u0026rsquo;s create a new Msg using the NewMsg() method and assign a sender address as well as a recipient address.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 package main import ( \u0026#34;github.com/wneessen/go-mail\u0026#34; \u0026#34;log\u0026#34; ) func main() { m := mail.NewMsg() if err := m.From(\u0026#34;toni.sender@example.com\u0026#34;); err != nil { log.Fatalf(\u0026#34;failed to set From address: %s\u0026#34;, err) } if err := m.To(\u0026#34;tina.recipient@example.com\u0026#34;); err != nil { log.Fatalf(\u0026#34;failed to set To address: %s\u0026#34;, err) } } In this little code snippet, first and foremost we import go-mail into our project. See the import statement in line 4. Next we create a new message in line 9. Lines 10 and 13 set the sender and recipient addresses. Since go-mail makes sure that you are providing valid mail addresses, we return an error. This way we can make sure that the provided address is accepted by go-mail and will not cause problems later on.\nNext we want to set a subject line for our message and fill the mail body with some content.\n1 2 m.Subject(\u0026#34;This is my first mail with go-mail!\u0026#34;) m.SetBodyString(mail.TypeTextPlain, \u0026#34;Do you like this mail? I certainly do!\u0026#34;) The first argument for SetBodyString() is a content type we need to provide. In our example the mail.TypeTextPlain basically represents a text/plain content type - meaning a plain text mail body.\nSending the mail Now that we have our mail message ready to go, let\u0026rsquo;s bring it on the way and send it out. For this we\u0026rsquo;ll use the Client, which handles the SMTP transmission.\n1 2 3 4 5 c, err := mail.NewClient(\u0026#34;smtp.example.com\u0026#34;, mail.WithPort(25), mail.WithSMTPAuth(mail.SMTPAuthPlain), mail.WithUsername(\u0026#34;my_username\u0026#34;), mail.WithPassword(\u0026#34;extremely_secret_pass\u0026#34;)) if err != nil { log.Fatalf(\u0026#34;failed to create mail client: %s\u0026#34;, err) } In this example we connect to the mail server with the hostname smtp.example.com and provide the Client with a couple of options like the port we want to connect to, the fact that we want to use SMTP PLAIN for authentication and the username and password.\nFinally we tell the client to deliver the mail.\n1 2 3 if err := c.DialAndSend(m); err != nil { log.Fatalf(\u0026#34;failed to send mail: %s\u0026#34;, err) } The DialAndSend() method takes care of establishing the connection and sending out the mail. You have the option to call them separately as well, but we won\u0026rsquo;t need this for the quick example.\nConclusion That was quite simple, wasn\u0026rsquo;t it? You successfully prepared a mail message and delivered it to the recipient via a 3rd party mail server. go-mail of course can do much more. Check out the in-depth documentation for all the features.\nFull example code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 package main import ( \u0026#34;github.com/wneessen/go-mail\u0026#34; \u0026#34;log\u0026#34; ) func main() { m := mail.NewMsg() if err := m.From(\u0026#34;toni.sender@example.com\u0026#34;); err != nil { log.Fatalf(\u0026#34;failed to set From address: %s\u0026#34;, err) } if err := m.To(\u0026#34;tina.recipient@example.com\u0026#34;); err != nil { log.Fatalf(\u0026#34;failed to set To address: %s\u0026#34;, err) } m.Subject(\u0026#34;This is my first mail with go-mail!\u0026#34;) m.SetBodyString(mail.TypeTextPlain, \u0026#34;Do you like this mail? I certainly do!\u0026#34;) c, err := mail.NewClient(\u0026#34;smtp.example.com\u0026#34;, mail.WithPort(25), mail.WithSMTPAuth(mail.SMTPAuthPlain), mail.WithUsername(\u0026#34;my_username\u0026#34;), mail.WithPassword(\u0026#34;extremely_secret_pass\u0026#34;)) if err != nil { log.Fatalf(\u0026#34;failed to create mail client: %s\u0026#34;, err) } if err := c.DialAndSend(m); err != nil { log.Fatalf(\u0026#34;failed to send mail: %s\u0026#34;, err) } } "},{"id":3,"href":"/reference/","title":"Reference","parent":"Welcome to the go-mail documentation","content":""},{"id":4,"href":"/examples/bulk-mailer/","title":"Bulk Mailer Example","parent":"Examples","content":"In this example we create a small bulk mailer for sending out the same mail to a bigger list of recipients. It is important for us to address the recipient directly in the mail, therefore we will make use of Go\u0026rsquo;s html/template and text/template system together with placeholders.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 package main import ( \u0026#34;fmt\u0026#34; ht \u0026#34;html/template\u0026#34; \u0026#34;log\u0026#34; \u0026#34;math/rand\u0026#34; \u0026#34;os\u0026#34; tt \u0026#34;text/template\u0026#34; \u0026#34;time\u0026#34; \u0026#34;github.com/wneessen/go-mail\u0026#34; ) // User is a simple type allowing us to set a firstname, lastname and mail address type User struct { Firstname string Lastname string EmailAddr string } // Our sender information that will be used in the FROM address field const ( senderName = \u0026#34;ACME Inc.\u0026#34; senderAddr = \u0026#34;noreply@acme.com\u0026#34; ) const ( textBodyTemplate = `Hi {{.Firstname}}, we are writing your to let you know that this week we have an amazing offer for you. Using the coupon code \u0026#34;GOMAIL\u0026#34; you will get a 20% discount on all our products in our online shop. Check out our latest offer on https://acme.com and use your discount code today! Your marketing team at ACME Inc.` htmlBodyTemplate = `\u0026lt;p\u0026gt;Hi {{.Firstname}},\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;we are writing your to let you know that this week we have an amazing offer for you. Using the coupon code \u0026#34;\u0026lt;strong\u0026gt;GOMAIL\u0026lt;/strong\u0026gt;\u0026#34; you will get a 20% discount on all our products in our online shop.\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;Check out our latest offer on \u0026lt;a href=\u0026#34;https://acme.com\u0026#34; target=\u0026#34;_blank\u0026#34;\u0026gt;https://acme.com\u0026lt;/a\u0026gt; and use your discount code today!\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;Your marketing team\u0026lt;br /\u0026gt; \u0026amp;nbsp;\u0026amp;nbsp;at ACME Inc.\u0026lt;/p\u0026gt;` ) func main() { // Define a list of users we want to mail to ul := []User{ {\u0026#34;Toni\u0026#34;, \u0026#34;Tester\u0026#34;, \u0026#34;toni.tester@example.com\u0026#34;}, {\u0026#34;Tina\u0026#34;, \u0026#34;Tester\u0026#34;, \u0026#34;tina.tester@example.com\u0026#34;}, {\u0026#34;John\u0026#34;, \u0026#34;Doe\u0026#34;, \u0026#34;john.doe@example.com\u0026#34;}, } // Prepare the different templates ttpl, err := tt.New(\u0026#34;texttpl\u0026#34;).Parse(textBodyTemplate) if err != nil { log.Fatalf(\u0026#34;failed to parse text template: %s\u0026#34;, err) } htpl, err := ht.New(\u0026#34;htmltpl\u0026#34;).Parse(htmlBodyTemplate) if err != nil { log.Fatalf(\u0026#34;failed to parse text template: %s\u0026#34;, err) } var ms []*mail.Msg r := rand.New(rand.NewSource(time.Now().UnixNano())) for _, u := range ul { rn := r.Int31() m := mail.NewMsg() if err := m.EnvelopeFrom(fmt.Sprintf(\u0026#34;noreply+%d@acme.com\u0026#34;, rn)); err != nil { log.Fatalf(\u0026#34;failed to set ENVELOPE FROM address: %s\u0026#34;, err) } if err := m.FromFormat(senderName, senderAddr); err != nil { log.Fatalf(\u0026#34;failed to set formatted FROM address: %s\u0026#34;, err) } if err := m.AddToFormat(fmt.Sprintf(\u0026#34;%s %s\u0026#34;, u.Firstname, u.Lastname), u.EmailAddr); err != nil { log.Fatalf(\u0026#34;failed to set formatted TO address: %s\u0026#34;, err) } m.SetMessageID() m.SetDate() m.SetBulk() m.Subject(fmt.Sprintf(\u0026#34;%s, we have a great offer for you!\u0026#34;, u.Firstname)) if err := m.SetBodyHTMLTemplate(htpl, u); err != nil { log.Fatalf(\u0026#34;failed to set HTML template as HTML body: %s\u0026#34;, err) } if err := m.AddAlternativeTextTemplate(ttpl, u); err != nil { log.Fatalf(\u0026#34;failed to set text template as alternative body: %s\u0026#34;, err) } ms = append(ms, m) } // Deliver the mails via SMTP c, err := mail.NewClient(\u0026#34;smtp.example.com\u0026#34;, mail.WithSMTPAuth(mail.SMTPAuthPlain), mail.WithTLSPortPolicy(mail.TLSMandatory), mail.WithUsername(os.Getenv(\u0026#34;SMTP_USER\u0026#34;)), mail.WithPassword(os.Getenv(\u0026#34;SMTP_PASS\u0026#34;)), ) if err := c.DialAndSend(ms...); err != nil { log.Fatalf(\u0026#34;failed to deliver mail: %s\u0026#34;, err) } log.Printf(\u0026#34;Bulk mailing successfully delivered.\u0026#34;) } Let\u0026rsquo;s take the example apart to look at some details\u0026hellip;\nAt first, in line 15, we define a new type for our users that we want to address. This is totally optional and is only done so we can easily work with a list of users and address them later on in our text template. How you handle this, is totally up to you and not mandatory for this to work.\nIn line 28 thru 48 we set up a simple text and HTML template mail body with placeholders that can be used with Go\u0026rsquo;s html/template and text/template.\nNext we set up a list of users, we want to send our great bulk mailing to. Line 52 uses the User type for this. With the preparation work done, we will start looping over all of our users in line 70. For each user we create a new *mail.Msg.\nFor bulk mailings it is common that the ENVELOPE FROM and the MAIL FROM differ, so that bounce mails are sent to some system that can mark those bounces in the local system as bounced. Therefore we set both of those from addresses in line 73 and line 76. The lines 79 to 85 should be of no surprise to you, if you already used go-mail before.\nOne more interesting thing happens in lines 86 thru 91 in which we use our prepared html/template and text/template templates and apply it to our mail message using m.SetBodyHTMLTemplate and m.AddAlternativeTextTemplate. We provide the whole user struct as data to that methods, so that html/template and text/template can take care of replacing placeholders in the mail body. Go-mail will take care of all the bells and whistles with the template handling for you. With our mail message now complete, we append it to our mail message slice in line 93.\nFinally we create a new Client and send out all of our prepared messages in one go by providing the whole slice of messages to Client.DialAndSend.\n"},{"id":5,"href":"/reference/client/options/","title":"Client options","parent":"The mail delivery client","content":" Option WithDebugLog() WithDSN() WithDSNMailReturnType() WithDSNRcptNotifyType() WithHELO() Option Signature 1 type Option func(*Client) error Client Option are functions that can be used as optional arguments for the NewClient() methods to override the default vaules of the returned Client.\nWithDebugLog() Signature 1 func WithDebugLog() Option Example 1 2 3 4 5 6 7 8 9 10 package main import \u0026#34;github.com/wneessen/go-mail\u0026#34; func main() { c, err := mail.NewClient(\u0026#34;mail.example.com\u0026#34;, mail.WithDebugLog()) if err != nil { panic(err) } } Version Introduced in go-mail v0.3.9 WithDebugLog enables debug logging of SMTP traffic on the Client. When enabled, any SMTP communication from the client to the server and vice-versa is logged to os.Stderr.\nIn the output C --\u0026gt; S is the communication from the client to the server and C \u0026lt;-- S represents the communication back from the server to the client.\nHere is an output example:\n2023/01/15 20:21:18 [DEBUG] C --\u0026gt; S: EHLO client.example.com 2023/01/15 20:21:18 [DEBUG] C \u0026lt;-- S: 250 server.example.com PIPELINING SIZE 152428800 ETRN STARTTLS AUTH LOGIN PLAIN AUTH=LOGIN PLAIN ENHANCEDSTATUSCODES 8BITMIME DSN 2023/01/15 20:21:18 [DEBUG] C --\u0026gt; S: STARTTLS 2023/01/15 20:21:18 [DEBUG] C \u0026lt;-- S: 220 2.0.0 Ready to start TLS 2023/01/15 20:21:18 [DEBUG] C --\u0026gt; S: EHLO client.example.com 2023/01/15 20:21:18 [DEBUG] C \u0026lt;-- S: 250 server.example.com PIPELINING SIZE 152428800 ETRN AUTH LOGIN PLAIN AUTH=LOGIN PLAIN ENHANCEDSTATUSCODES 8BITMIME DSN 2023/01/15 20:21:18 [DEBUG] C --\u0026gt; S: AUTH LOGIN 2023/01/15 20:21:18 [DEBUG] C \u0026lt;-- S: 334 VXNlcm5hbWU6 2023/01/15 20:21:18 [DEBUG] C --\u0026gt; S: 2023/01/15 20:21:20 [DEBUG] C \u0026lt;-- S: 535 5.7.8 Error: authentication failed: VXNlcm5hbWU6 WithDSN() Signature 1 func WithDSN() Option Example 1 2 3 4 5 6 7 8 9 10 package main import \u0026#34;github.com/wneessen/go-mail\u0026#34; func main() { c, err := mail.NewClient(\u0026#34;mail.example.com\u0026#34;, mail.WithDSN()) if err != nil { panic(err) } } The WithDSN option function tells the Client to request DSNs (if the server supports it) as described in RFC 1891.\nDSNs (Delivery Status Notification) are an extension to the SMTP protocol and need to be supported by the sending server. The RFC for DSNs defines different parameters of which we\u0026rsquo;ve implemented the once which we think make most sense for go-mail:\nThe RET extension for the MAIL FROM command, to let the user specify if a DSN should contain the full mail (FULL) or only headers (HDRS) of the sent mail. The NOTIFY extension that allows the user to request a DSN for the different types of allowed situations: NEVER, SUCCESS, FAILURE and DELAY ENVID and ORCPT are currently not supported but might follow in a later relaese (please open an issue if you see usefulness in this).\nBy default WithDSN() sets the FULL Mail From Return Option and the SUCCESS and FAILURE Recipient Notify Options. If you like to use other settings for the DSN, please see the documentation for WithDSNMailReturnType and WithDSNRcptNotifyType\nWithDSNMailReturnType() Signature 1 func WithDSNMailReturnType(DSNMailReturnOption) Option Example 1 2 3 4 5 6 7 8 9 10 package main import \u0026#34;github.com/wneessen/go-mail\u0026#34; func main() { c, err := mail.NewClient(\u0026#34;mail.example.com\u0026#34;, mail.WithDSNMailReturnType(mail.DSNMailReturnFull)) if err != nil { panic(err) } } WithDSNMailReturnType enables the Client to request DSNs (if the server supports it) as described in the RFC 1891 and set the MAIL FROM Return option type to the given DSNMailReturnOption\ngo-mail has the following two DSNMailReturnOption type already built-in:\nDSNMailReturnHeadersOnly: requests that only the headers of the message be returned. See: RFC 1891, Section 5.3 DSNMailReturnFull: requests that the entire message be returned in any \u0026ldquo;failed\u0026rdquo; delivery status notification issued for this recipient See: RFC 1891, Section 5.3 WithDSNRcptNotifyType() Signature 1 func WithDSNRcptNotifyType(...DSNRcptNotifyOption) Option Example 1 2 3 4 5 6 7 8 9 10 11 12 package main import \u0026#34;github.com/wneessen/go-mail\u0026#34; func main() { c, err := mail.NewClient(\u0026#34;mail.example.com\u0026#34;, mail.WithDSNRcptNotifyType(mail.DSNRcptNotifyFailure, mail.DSNRcptNotifyDelay, mail.DSNRcptNotifySuccess)) if err != nil { panic(err) } } WithDSNRcptNotifyType enables the Client to request DSNs as described in RFC 1891 and sets the RCPT TO notify options to the given list of DSNRcptNotifyOption\ngo-mail has the following DSNRcptNotifyOption types already built-in:\nDSNRcptNotifyNever: requests that a DSN not be returned to the sender under any conditions. See: RFC 1891, Section 5.1 DSNRcptNotifySuccess: requests that a DSN be issued on successful delivery See: RFC 1891, Section 5.1 DSNRcptNotifyFailure: requests that a DSN be issued on delivery failure See: RFC 1891, Section 5.1 DSNRcptNotifyDelay: indicates the sender\u0026rsquo;s willingness to receive \u0026ldquo;delayed\u0026rdquo; DSNs. Delayed DSNs may be issued if delivery of a message has been delayed for an unusual amount of time (as determined by the MTA at which the message is delayed), but the final delivery status (whether successful or failure) cannot be determined. The absence of the DELAY keyword in a NOTIFY parameter requests that a \u0026ldquo;delayed\u0026rdquo; DSN NOT be issued under any conditions. See: RFC 1891, Section 5.1 WithHELO() Signature 1 func WithHELO(string) Option Example 1 2 3 4 5 6 7 8 9 10 package main import \u0026#34;github.com/wneessen/go-mail\u0026#34; func main() { c, err := mail.NewClient(\u0026#34;mail.example.com\u0026#34;, mail.WithHELO(\u0026#34;test.example.com\u0026#34;)) if err != nil { panic(err) } } WithHELO instructs the Client to use the provided string as HELO/EHLO greeting host. By default the Client will use Go\u0026rsquo;s os.Hostname() method to get the local hostname and use that for the HELO/EHLO greeting. WithHELO will override this.\n"},{"id":6,"href":"/community/","title":"Communities","parent":"Welcome to the go-mail documentation","content":""},{"id":7,"href":"/community/guide/","title":"Community Guide","parent":"Communities","content":"The go-mail community is growing and if you\u0026rsquo;re reading this, chances are that you want to join, too!\nResources Code of Conduct Support- and annoucement channels Contributing Developing New Features Fixing bugs Testing Documentation Translation Support Resources Code of Conduct In our community, we follow our Code of Conduct and ask everybody who likes to participate to act accordingly.\nSupport- and annoucement channels Mastodon: Follow us on Mastodon to receive recent news about go-mail go-mail forum: Receive announcements and start discussions about go-mail. Github issues: If you have a bug to report or feature to request, please use GitHub issues. Please respect the rules specified in each repository\u0026rsquo;s issue template. Discord: A place for go-mail devs and users to meet and chat in real time. Contributing go-mail is an open source, community driven project. We welcome anyone to join us in contributing to the project. This documentation is aimed at anyone wishing to get familiar with the project and the development processes.\nDeveloping new features Fixing bugs Testing Documenation Translation Support Developing New Features We are always keen to add features to go-mail. The process for adding new features are as follows:\nCheck the issue section on Github for available issues with the \u0026ldquo;TODO\u0026rdquo; or \u0026ldquo;help wanted\u0026rdquo; tag If no open \u0026ldquo;TODO\u0026rdquo;/\u0026ldquo;help wanted\u0026rdquo; issue is found or the feature you have in mind is not covered, please open a proposal issue for that specific feature and wait for the \u0026ldquo;OK\u0026rdquo; from the project maintainers Before developing, check that the issue includes the following information: The purpose of the enhancement What is out of scope for the enhancement If the issue does not include this information, feel free to request the information from the person who opened the issue. Sometimes placeholder issues are created and require more details Comment on the issue stating if you wish to develop the feature Clone the repository and create a branch with the format feature/\u0026lt;issue_number\u0026gt;_\u0026lt;issue_title\u0026gt; New features often require documentation so please ensure you have also added or updated the documentation as part of the changes Please make sure that your code has the required test coverage Once the feature is ready for testing, create a draft PR. Please ensure the PR description has the test scenarios and test cases listed with checkmarks, so that others can know what still needs to be tested Once all the testing is completed, please update the status of the PR from draft and leave a message Any PRs opened without a corresponding issue may be rejected. Fixing bugs The process for fixing bugs are as follows:\nCheck the Github issues and select a bug to fix Before developing, check that the issue includes the following information: The scope of the issue including platforms affected The steps to reproduce. Sometimes bugs are opened that are not go-mail issues and the onus is on the reporter to prove that it is a go-mail issue with a minimal reproducible example If the issue does not include this information, feel free to request the information from the person who opened the issue Comment on the issue stating you wish to develop a fix Clone the repository and create a branch with the format bugfix/\u0026lt;issue_number\u0026gt;_\u0026lt;issue_title\u0026gt; Once the fix is ready for testing, create a draft PR. Please ensure the PR description has the test scenarios and test cases listed with checkmarks, so that others can know what still needs to be tested Once all the testing is completed, please update the status of the PR from draft and leave a message. There is nothing stopping you from opening a issue and working on it yourself, but please be aware that all bugfixes should be discussed as the approach may have unintended side effects. Any PRs opened without a corresponding issue may be rejected. Testing Testing is vitally important to ensure quality in the project. There are a couple of scenarios where testing can really help the project:\nTesting if a bug is reproducible on your local system Testing PRs to ensure that they work correctly If you chose to test if someone\u0026rsquo;s bug report is reproducible on your local system, then feel free to add a comment on the issue confirming this with the output of your test program.\nTo test PRs, choose a PR to test and check if the PR description has the testing scenarios listed. If not, please ask the person who opened the PR to provide that list. Once you have determined a valid test scenario, please report your findings on the PR.\nIf you ever need more clarity or help on testing, please ask a question in the Github forum or on Discord.\nDocumentation While we require proper GoDoc documenation comments in the code, this website is meant as more in-depth documenation of features and the project itself.\nSince documenattion is hard and the website is still in an incomplete state, any contribution to this is greatly appreciated. Features without documentation are condidered \u0026ldquo;unfinished\u0026rdquo; to the project, it\u0026rsquo;s as important as the code.\nThe website is built on Hugo using the Geekdocs theme. It\u0026rsquo;s very simple and basically consists of markdown files. There are instructions on how to install the website on your local computer in the website\u0026rsquo;s repository.\nTranslation The default documents of the go-mail project are English documents. We use the \u0026ldquo;Crowdin\u0026rdquo; tool to translate documents in other languages and synchronize them to the website. You can join our project and submit your translations to make contributions.\nCurrently the only supported 2nd language is German, but we are keen to add other languages as well. Please request them via a Github issue in the go-mail-website repository.\nSupport A great way to contribute to the project is to help others who are experiencing difficulty. This is normally reported as a issue or a message on the #go-mail Discord channel. Even just clarifying the issue can really help out. Sometimes, when an issue is discussed and gets resolved, we create a guide out of it to help others who face the same issues.\n"},{"id":8,"href":"/community/merch/","title":"Merchandising","parent":"Communities","content":"Thanks to our wonderful friends at HelloTux we can offer great go-mail merchandising. All merch articles are embroidery to provide the best and most long-lasting quality possible.\nIf you want to support the open source community and represent your favourite Go mail library with some cool drip, check out our merch shop at: https://www.hellotux.com/go-mail.\n"},{"id":9,"href":"/security/","title":"Security policy","parent":"Welcome to the go-mail documentation","content":" Known vulnerabilities Even though there is no known security vulnerability in go-mail, you can always check the security advisories page of our GitHub project.\nReporting a Vulnerability To report (possible) security issues in go-mail, please either send a mail to security@go-mail.dev or use Github\u0026rsquo;s private reporting feature. Reports are always welcome. Even if you are not 100% certain that a specific issue you found counts as a security issue, we\u0026rsquo;d love to hear the details, so we can figure out together if the issue in question needds to be addressed.\nTypically, you will receive an answer within a day or even within a few hours.\nEnd-to-End encryption You can send OpenPGP/GPG encrpyted mails to the security@go-mail.dev address.\nOpenPGP/GPG public key:\n-----BEGIN PGP PUBLIC KEY BLOCK----- xjMEY8RwPBYJKwYBBAHaRw8BAQdAiLsW7pv+CCMq5Ol0hbIB1HnJI97u3zJw Wslr7GJzgOzNK3NlY3VyaXR5QGdvLW1haWwuZGV2IDxzZWN1cml0eUBnby1t YWlsLmRldj7CjAQQFgoAPgUCY8RwPAQLCQcICRCgTBOxf8keAAMVCAoEFgAC AQIZAQIbAwIeARYhBAoWEB7Y0bE7zcIOuaBME7F/yR4AAAByugD9HabWXsyD aPIDrIS97OBA1OLltB4NPT5ba9whKRxTEmMBALBiB2ML4ZTrjLqI6UbGkhJq mWeMtvmU0chZT7WNBO0PzjgEY8RwPBIKKwYBBAGXVQEFAQEHQGDEccz6gvl5 t8cMMb/Dy2l0elRZL+Nd0gOhnbWMWlArAwEIB8J4BBgWCAAqBQJjxHA8CRCg TBOxf8keAAIbDBYhBAoWEB7Y0bE7zcIOuaBME7F/yR4AAADaMwD9EvEA3NSN NtdSaeL/euh6oRRiCjKzh5bIqZiQXqMlIOoBAJvPE2facs8MISwTtDoHW0sD WdOs3yBpGlGCs5WEqvQH=zn96 -----END PGP PUBLIC KEY BLOCK----- "},{"id":10,"href":"/examples/simple-mailer/","title":"Simple Mailer Example","parent":"Examples","content":"This example is the most simple piece of code that is required to successfully send a mail with go-mail.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 package main import ( \u0026#34;log\u0026#34; \u0026#34;os\u0026#34; \u0026#34;github.com/wneessen/go-mail\u0026#34; ) func main() { msg := mail.NewMsg() if err := msg.From(\u0026#34;toni@tester.com\u0026#34;); err != nil { log.Fatalf(\u0026#34;failed to set FROM address: %s\u0026#34;, err) } if err := msg.To(\u0026#34;tina@recipient.org\u0026#34;); err != nil { log.Fatalf(\u0026#34;failed to set TO address: %s\u0026#34;, err) } msg.Subject(\u0026#34;This is my first test mail with go-mail!\u0026#34;) msg.SetBodyString(mail.TypeTextPlain, \u0026#34;This will be the content of the mail.\u0026#34;) // Deliver the mails via SMTP c, err := mail.NewClient(\u0026#34;smtp.example.com\u0026#34;, mail.WithSMTPAuth(mail.SMTPAuthPlain), mail.WithTLSPortPolicy(mail.TLSMandatory), mail.WithUsername(os.Getenv(\u0026#34;SMTP_USER\u0026#34;)), mail.WithPassword(os.Getenv(\u0026#34;SMTP_PASS\u0026#34;)), ) if err != nil { log.Fatalf(\u0026#34;failed to create new mail delivery client: %s\u0026#34;, err) } if err := c.DialAndSend(msg); err != nil { log.Fatalf(\u0026#34;failed to deliver mail: %s\u0026#34;, err) } log.Printf(\u0026#34;Test mail successfully delivered.\u0026#34;) } This example will send a very basic test mail from toni@tester.com to tina@recipient.org.\nFirst, in line 11, we create a new Msg. The Msg type holds everything that is required for your mail message. Think of it like a new mail within your mail user agent. The Msg type provides you with all of the methods that are required to prepare and format your mail message.\nIn line 12 thru 14 we set the sender address. In this case it\u0026rsquo;s toni@tester.com. Since go-mail is doing a lot of validation under the hood, it will make sure that the provided mail address is valid. Therefore we check the returned error. In line 15 thru 17 we do the same for the recipient address. The mail will be sent to tina@recipient.org.\nNext, in line 18 we set our subject for our mail message. Followed by setting a simple string as message body in line 19. The first argument for Msg.SetBodyString() is a MIME content type. In this case we use mail.TypeTextPlain for the mail body - so a simple plain/text mail body.\nNow that our simple mail message is prepared for delivery, we can create a Client. The Client in go-mail handles the connection to a mail server and everything related to it. In line 22 thru 25 we initialize a new Client type and give it some options. The first argument is the mail server we want to connect to. In our example it\u0026rsquo;s smtp.example.com. Then we tell the Client that we need to perform SMTP Auth via the PLAIN auth method. The mail.WithSMTPAuth(mail.SMTPAuthPlain) option handles this. With the mail.WithTLSPortPolicy(mail.TLSMandatory) option, we tell the Client that we require a TLS connection for sending our mail. We set it to mandatory mode, so that the Client will stop processing if it cannot accomplish a TLS secured connection. With the mail.WithUsername() and mail.WithPassword() options, we let the Client know what username and password to use for the SMTP auth. Lines 26-28 check if the Client invocation worked without errors.\nFinally, in line 29-32 we send out our mail message using our mail client with the Client.DialAndSend() method. We print out a brief message on success or throw an error in case the delivery failed.\n"},{"id":11,"href":"/tags/","title":"Tags","parent":"Welcome to the go-mail documentation","content":""},{"id":12,"href":"/reference/client/","title":"The mail delivery client","parent":"Reference","content":"In go-mail the Client is responsible for the mail delivery with remote mail servers that communicate via the SMTP protocol.\nNewClient() Client Close() DialAndSend() DialAndSendWithContext() NewClient() Signature 1 func NewClient(string, ...Option) (*Client, error) Example 1 2 3 4 5 6 7 8 9 10 package main import \u0026#34;github.com/wneessen/go-mail\u0026#34; func main() { c, err := mail.NewClient(\u0026#34;mail.example.com\u0026#34;) if err != nil { panic(err) } } To create a new Client, you can use the NewClient() method. As first argument it requires the hostname of the sending SMTP server. Optionally you can provide a list of Option funcionts. These option functions can be used to override the default settings of the Client.\nCheck the Options documentation for in-depth details to all available Options.\nClient Signature 1 2 3 type Client struct { // contains filtered or unexported fields } Close() Signature 1 func (*Client) Close() error Example 1 2 3 4 5 6 7 8 9 10 11 package main import \u0026#34;github.com/wneessen/go-mail\u0026#34; func main() { c, err := mail.NewClient(\u0026#34;mail.example.com\u0026#34;) if err != nil { panic(err) } defer c.Close() } Close() closes the connection to the SMTP server the Client is connected to. It returns an error in case the Client has no active connection or if closing the connection fails.\nDialAndSend() Signature 1 func (*Client) DialAndSend(...*Msg) error Example 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 package main import \u0026#34;github.com/wneessen/go-mail\u0026#34; func main() { from := \u0026#34;Toni Tester \u0026lt;toni@example.com\u0026gt;\u0026#34; to := \u0026#34;Alice \u0026lt;alice@example.com\u0026gt;\u0026#34; server := \u0026#34;mail.example.com\u0026#34; m := mail.NewMsg() if err := m.From(from); err != nil { panic(err) } if err := m.To(to); err != nil { panic(err) } m.Subject(\u0026#34;This is a great subject\u0026#34;) c, err := mail.NewClient(server) if err != nil { panic(err) } if err := c.DialAndSend(m); err != nil { panic(err) } } The DialAndSend() method is an alias for DialAndSendWithContext() with a default context.Background context. DialAndSend() takes a list of Msg pointer as argument(s) and returns an error in case any of the performed actions fails.\nDialAndSendWithContext() Signature 1 func (*Client) DialAndSendWithContext(context.Context, ...*Msg) error Example 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 package main import \u0026#34;github.com/wneessen/go-mail\u0026#34; func main() { from := \u0026#34;Toni Tester \u0026lt;toni@example.com\u0026gt;\u0026#34; to := \u0026#34;Alice \u0026lt;alice@example.com\u0026gt;\u0026#34; server := \u0026#34;mail.example.com\u0026#34; m := mail.NewMsg() if err := m.From(from); err != nil { panic(err) } if err := m.To(to); err != nil { panic(err) } m.Subject(\u0026#34;This is a great subject\u0026#34;) c, err := mail.NewClient(server) if err != nil { panic(err) } ctx := context.Background() if err := c.DialAndSendWithContext(ctx, m); err != nil { panic(err) } } The DialAndSendWithContext() is a one-for-all shortcut method on the Client. Once the Client is created, calling the DialAndSendWithContext() method will have it connect to the configured server, send out the given mail Msg and finalize by closing the connection again.\nThe first argument of the method is a context.Context followed by a list of one or more Msg pointers. DialAndSendWithContext() does return an error in case any of the performed actions fails.\n"},{"id":13,"href":"/","title":"Welcome to the go-mail documentation","parent":"","content":" go-mail is an easy to use Go library for formating and sending mails. It uses idiomatic Go style and follows best practice with sane defaults. The library only dependends on the Go Standard Library.\ngo-mail works like a programatic email client and provides lots of methods and functionalities you would consider standard in a MUA.\nGet started using go-mail Feature highlights Standard Library dependant go-mail does not require any third-party modules and only runs on the Go standard library\nModern, idiomatic Go We are using modern and idiotmatic Go standards with this library and follow state-of-the-art best practices with sane defaults\nFull TLS support go-mail supports implicit STARTTLS with different policies as well as explicit SSL/TLS for connections to sending mail servers\nContexts We make use of Go contexts for better control flow and timeout/cancelation handling\nSMTP Authentication Support for three common SMTP authentication mechanisms (LOGIN, PLAIN, CRAM-MD5) as well as custom authentications.\nMail address validation go-mail follows RFC5322 and validates the provided mail addresses\nCommon mail header support go-mail brings generators for lots of common mail headers (Message-ID, Date, Bulk-Precedence, Priority, etc.)\nConnection reusing You can send mulitple mails over the same SMTP connection\nAttachments/Embeds Full support for attachments and inline embeds from different sources (local file system, io.Reader or embed.FS)\nEncodings and content types go-mail supports different encondings and content types out of the box\nMiddlewares Middleware support for 3rd-party libraries to alter mail message to their need\nSendmail and file storage Support for sending mail messages through a local sendmail installation as well as output to local files (e. g. as .eml files to disk to open them in a MUA)\nMDNs and DSNs go-mail brings support for requestng MDNs (RFC 8098) and DSNs (RFC 1891)\nTemplate support Support for Go\u0026rsquo;s html/template and text/template (as message body, alternative part or attachment/emebed)\nDKIM support DKIM signature support via the go-mail-middlware/dkim middleware\nDebug logging Support for the SMTP client to log any SMTP communication to STDERR for debug purposes\nCustom delivery errors With the SendError type the user is able to get detailed information about delivery errors including if the error is of temporary nature or not\nSupport We have a support and general discussion channel on Discord. Find us at: #go-mail\n"}]