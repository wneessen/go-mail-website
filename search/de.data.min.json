[{"id":0,"href":"/de/examples/","title":"Beispiele","parent":"Willkommen in der go-mail-Dokumentation","content":""},{"id":1,"href":"/de/getting-started/introduction/","title":"Einführung","parent":"Erste Schritte","content":"Diese kurze Anleitung zeigt dir, wie du go-mail von der Installation bis zum Versand deiner ersten Mail nutzen kannst.\nVoraussetzungen Installation Deine erste Mail verschicken Eine neue Nachricht erstellen Versenden der Mail Zusammenfassung Vollständiger Beispielcode Voraussetzungen go-mail erfordert eine funktionierende Go-Installation (Version 1.16+). Lade Go von der Go Downloads Seite.\nInstallation go-mail kann über den Go-Modul-Installationsmechanismus mit dem Befehl go get installiert werden.\nUm die neueste Version von go-mail zu installieren, gehst du in deinen Projektordner und importierst das Modul einfach mit dem folgenden Befehl:\n1 $ go get github.com/wneessen/go-mail Deine erste Mail verschicken go-mail besteht aus zwei Hauptkomponenten. Die Msg, die die Mail-Nachricht darstellt und der Client, der sich um die Mail-Zustellung über einen SMTP-Dienst kümmert.\nEine neue Nachricht erstellen Zuerst erstellen wir eine neue Msg mit der Methode NewMsg() und weisen eine Absender- und eine Empfängeradresse zu.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 package main import ( \u0026#34;github.com/wneessen/go-mail\u0026#34; \u0026#34;log\u0026#34; ) func main() { m := mail.NewMsg() if err := m.From(\u0026#34;toni.sender@example.com\u0026#34;); err != nil { log.Fatalf(\u0026#34;failed to set From address: %s\u0026#34;, err) } if err := m.To(\u0026#34;tina.recipient@example.com\u0026#34;); err != nil { log.Fatalf(\u0026#34;failed to set To address: %s\u0026#34;, err) } } In diesem kleinen Codeschnipsel importieren wir zuallererst go-mail in unser Projekt. Siehe die Import-Anweisung in Zeile 4. Als nächstes erstellen wir eine neue Nachricht in Zeile 9. In den Zeilen 10 und 13 werden die Absender- und Empfängeradressen festgelegt. Da go-mail sicherstellt, dass du gültige Mailadressen angibst, geben wir einen error zurück. Auf diese Weise können wir sicherstellen, dass die angegebene Adresse von go-mail akzeptiert wird und später keine Probleme verursacht.\nAls Nächstes wollen wir eine Betreffzeile für unsere Nachricht festlegen und den Mailtext mit einem Inhalt füllen.\n1 2 m.Subject(\u0026#34;Das ist meine erste Mail mit go-mail!\u0026#34;) m.SetBodyString(mail.TypeTextPlain, \u0026#34;Gefällt dir diese Mail? Mir auf jeden Fall!\u0026#34;) Das erste Argument für SetBodyString() ist ein Inhaltstyp, den wir angeben müssen. In unserem Beispiel repräsentiert der mail.TypeTextPlain einen text/plain Inhaltstyp - also einen reinen Textkörper.\nVersenden der Mail Jetzt, wo wir unsere E-Mail-Nachricht versandfertig haben, können wir sie auf den Weg bringen und verschicken. Hierfür verwenden wir den Client, der die SMTP-Übertragung abwickelt.\n1 2 3 4 5 c, err := mail.NewClient(\u0026#34;smtp.example.com\u0026#34;, mail.WithPort(25), mail.WithSMTPAuth(mail.SMTPAuthPlain), mail.WithUsername(\u0026#34;my_username\u0026#34;), mail.WithPassword(\u0026#34;extremely_secret_pass\u0026#34;)) if err != nil { log.Fatalf(\u0026#34;failed to create mail client: %s\u0026#34;, err) } In diesem Beispiel verbinden wir uns mit dem Mailserver hinter dem Hostnamen smtp.example.com und geben dem Client ein paar Optionen wie den Port, mit dem wir uns verbinden wollen, die Tatsache, dass wir SMTP PLAIN für die Authentifizierung verwenden wollen und den Benutzernamen und das Passwort, mit.\nAbschließend weisen wir den Client an, die Mail zuzustellen.\n1 2 3 if err := c.DialAndSend(m); err != nil { log.Fatalf(\u0026#34;failed to send mail: %s\u0026#34;, err) } Die Methode DialAndSend() kümmert sich um den Aufbau der Verbindung und den Versand der Mail. Du kannst sie auch separat aufrufen, aber das benötigen wir für dieses kurze Beispiel nicht.\nZusammenfassung Das war doch ganz einfach, oder? Du hast erfolgreich eine E-Mail-Nachricht vorbereitet und sie dem Empfänger über einen Mailserver eines Drittanbieters zugestellt. go-mail kann natürlich noch viel mehr. In der ausführlichen Dokumentation findest du alle Funktionen.\nVollständiger Beispielcode 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 package main import ( \u0026#34;github.com/wneessen/go-mail\u0026#34; \u0026#34;log\u0026#34; ) func main() { m := mail.NewMsg() if err := m.From(\u0026#34;toni.sender@example.com\u0026#34;); err != nil { log.Fatalf(\u0026#34;failed to set From address: %s\u0026#34;, err) } if err := m.To(\u0026#34;tina.recipient@example.com\u0026#34;); err != nil { log.Fatalf(\u0026#34;failed to set To address: %s\u0026#34;, err) } m.Subject(\u0026#34;This is my first mail with go-mail!\u0026#34;) m.SetBodyString(mail.TypeTextPlain, \u0026#34;Gefällt dir diese Mail? Mir auf jeden Fall!\u0026#34;) c, err := mail.NewClient(\u0026#34;smtp.example.com\u0026#34;, mail.WithPort(25), mail.WithSMTPAuth(mail.SMTPAuthPlain), mail.WithUsername(\u0026#34;my_username\u0026#34;), mail.WithPassword(\u0026#34;extremely_secret_pass\u0026#34;)) if err != nil { log.Fatalf(\u0026#34;failed to create mail client: %s\u0026#34;, err) } if err := c.DialAndSend(m); err != nil { log.Fatalf(\u0026#34;failed to send mail: %s\u0026#34;, err) } } "},{"id":2,"href":"/de/getting-started/","title":"Erste Schritte","parent":"Willkommen in der go-mail-Dokumentation","content":""},{"id":3,"href":"/de/reference/","title":"Referenz","parent":"Willkommen in der go-mail-Dokumentation","content":""},{"id":4,"href":"/de/examples/bulk-mailer/","title":"Beispiel für Massenmailer","parent":"Beispiele","content":"In diesem Beispiel erstellen wir einen kleinen Massenversender, um die gleiche Mail an eine größere Liste von Empfängern zu versenden. Für uns ist es wichtig, den Empfänger in der Mail direkt anzusprechen. Deshalb werden wir das html/template und text/template System von Go zusammen mit Platzhaltern verwenden.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 package main import ( \u0026#34;fmt\u0026#34; ht \u0026#34;html/template\u0026#34; \u0026#34;log\u0026#34; \u0026#34;math/rand\u0026#34; \u0026#34;os\u0026#34; tt \u0026#34;text/template\u0026#34; \u0026#34;time\u0026#34; \u0026#34;github.com/wneessen/go-mail\u0026#34; ) // User is a simple type allowing us to set a firstname, lastname and mail address type User struct { Firstname string Lastname string EmailAddr string } // Our sender information that will be used in the FROM address field const ( senderName = \u0026#34;ACME Inc.\u0026#34; senderAddr = \u0026#34;noreply@acme.com\u0026#34; ) const ( textBodyTemplate = `Hi {{.Firstname}}, we are writing your to let you know that this week we have an amazing offer for you. Using the coupon code \u0026#34;GOMAIL\u0026#34; you will get a 20% discount on all our products in our online shop. Check out our latest offer on https://acme.com and use your discount code today! Your marketing team at ACME Inc.` htmlBodyTemplate = `\u0026lt;p\u0026gt;Hi {{.Firstname}},\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;we are writing your to let you know that this week we have an amazing offer for you. Using the coupon code \u0026#34;\u0026lt;strong\u0026gt;GOMAIL\u0026lt;/strong\u0026gt;\u0026#34; you will get a 20% discount on all our products in our online shop.\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;Check out our latest offer on \u0026lt;a href=\u0026#34;https://acme.com\u0026#34; target=\u0026#34;_blank\u0026#34;\u0026gt;https://acme.com\u0026lt;/a\u0026gt; and use your discount code today!\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;Your marketing team\u0026lt;br /\u0026gt; \u0026amp;nbsp;\u0026amp;nbsp;at ACME Inc.\u0026lt;/p\u0026gt;` ) func main() { // Define a list of users we want to mail to ul := []User{ {\u0026#34;Toni\u0026#34;, \u0026#34;Tester\u0026#34;, \u0026#34;toni.tester@example.com\u0026#34;}, {\u0026#34;Tina\u0026#34;, \u0026#34;Tester\u0026#34;, \u0026#34;tina.tester@example.com\u0026#34;}, {\u0026#34;John\u0026#34;, \u0026#34;Doe\u0026#34;, \u0026#34;john.doe@example.com\u0026#34;}, } // Prepare the different templates ttpl, err := tt.New(\u0026#34;texttpl\u0026#34;).Parse(textBodyTemplate) if err != nil { log.Fatalf(\u0026#34;failed to parse text template: %s\u0026#34;, err) } htpl, err := ht.New(\u0026#34;htmltpl\u0026#34;).Parse(htmlBodyTemplate) if err != nil { log.Fatalf(\u0026#34;failed to parse text template: %s\u0026#34;, err) } var ms []*mail.Msg r := rand.New(rand.NewSource(time.Now().UnixNano())) for _, u := range ul { rn := r.Int31() m := mail.NewMsg() if err := m.EnvelopeFrom(fmt.Sprintf(\u0026#34;noreply+%d@acme.com\u0026#34;, rn)); err != nil { log.Fatalf(\u0026#34;failed to set ENVELOPE FROM address: %s\u0026#34;, err) } if err := m.FromFormat(senderName, senderAddr); err != nil { log.Fatalf(\u0026#34;failed to set formatted FROM address: %s\u0026#34;, err) } if err := m.AddToFormat(fmt.Sprintf(\u0026#34;%s %s\u0026#34;, u.Firstname, u.Lastname), u.EmailAddr); err != nil { log.Fatalf(\u0026#34;failed to set formatted TO address: %s\u0026#34;, err) } m.SetMessageID() m.SetDate() m.SetBulk() m.Subject(fmt.Sprintf(\u0026#34;%s, we have a great offer for you!\u0026#34;, u.Firstname)) if err := m.SetBodyHTMLTemplate(htpl, u); err != nil { log.Fatalf(\u0026#34;failed to set HTML template as HTML body: %s\u0026#34;, err) } if err := m.AddAlternativeTextTemplate(ttpl, u); err != nil { log.Fatalf(\u0026#34;failed to set text template as alternative body: %s\u0026#34;, err) } ms = append(ms, m) } // Deliver the mails via SMTP c, err := mail.NewClient(\u0026#34;smtp.example.com\u0026#34;, mail.WithSMTPAuth(mail.SMTPAuthPlain), mail.WithTLSPortPolicy(mail.TLSMandatory), mail.WithUsername(os.Getenv(\u0026#34;SMTP_USER\u0026#34;)), mail.WithPassword(os.Getenv(\u0026#34;SMTP_PASS\u0026#34;)), ) if err := c.DialAndSend(ms...); err != nil { log.Fatalf(\u0026#34;failed to deliver mail: %s\u0026#34;, err) } log.Printf(\u0026#34;Bulk mailing successfully delivered.\u0026#34;) } } } } Nehmen wir das Beispiel mal auseinander, um uns ein paar Details anzuschauen\u0026hellip;\nZuerst, in Zeile 15, definieren wir einen neuen Typ für unsere Nutzer, die wir ansprechen wollen. Das ist völlig optional und wird nur gemacht, damit wir mit einer Liste von Benutzern arbeiten und sie später in unserer Textvorlage ansprechen können. Wie du das handhabst, liegt ganz bei dir und ist nicht zwingend notwendig, damit es funktioniert.\nIn Zeile 28 bis 48 haben wir einen einfachen Text- und HTML-Template-Mailkörper mit Platzhaltern eingerichtet, der mit Go\u0026rsquo;s html/template und text/template verwendet werden kann.\nAls Nächstes erstellen wir eine Liste von Nutzern, an die wir unser tolles Massenmailing schicken wollen. Zeile 52 verwendet dafür den Typ User. Nachdem wir die Vorbereitungen getroffen haben, beginnen wir in Zeile 70 mit einer Schleife über alle unsere Benutzer. Für jeden Benutzer erstellen wir eine neue *mail.Msg.\nBei Massenmails ist es üblich, dass die ENVELOPE FROM und die MAIL FROM unterschiedlich sind, so dass Bounce-Mails an ein System gesendet werden, das diese Bounces im lokalen System als gebounced markieren kann. Deshalb setzen wir diese beiden von Adressaten in Zeile 73 und Zeile 76. Die Zeilen 79 bis 85 sollten dich nicht überraschen, wenn du go-mail schon einmal benutzt hast.\nEine weitere wichtige Sache passiert in Zeilen 86 bis 91, in denen wir unsere vorbereiteten html/template und text/template Vorlagen verwenden und sie mit m.SetBodyHTMLTemplate und m.AddAlternativeTextTemplate auf unsere E-Mail-Nachricht anwenden. Wir stellen dieser Methode die gesamte Benutzerstruktur als Daten zur Verfügung, so dass html/template und text/template sich um das Ersetzen der Platzhalter im Mailkörper kümmern können. Go-mail kümmert sich um den ganzen Schnickschnack mit der Vorlagenbearbeitung für dich. Da unsere Mailnachricht nun vollständig ist, fügen wir sie in Zeile 93 an unsere Mailnachrichtenscheibe an.\nZum Schluss erstellen wir einen neuen Client und senden alle unsere vorbereiteten Nachrichten in einem Rutsch, indem wir die gesamte Nachrichtenscheibe an Client.DialAndSend übergeben.\n"},{"id":5,"href":"/de/reference/client/options/","title":"Client-Optionen","parent":"Der Client für die Mailzustellung","content":" Option WithDebugLog() WithDSN() WithDSNMailReturnType() WithDSNRcptNotifyType() WithHELO() Option Signature 1 type Option func(*Client) error Client Option sind Funktionen, die als optionale Argumente für die NewClient() Methoden verwendet werden können, um die Standardeinstellungen des zurückgegebenen Client zu überschreiben.\nWithDebugLog() Signature 1 func WithDebugLog() Option Example 1 2 3 4 5 6 7 8 9 10 package main import \u0026#34;github.com/wneessen/go-mail\u0026#34; func main() { c, err := mail.NewClient(\u0026#34;mail.example.com\u0026#34;, mail.WithDebugLog()) if err != nil { panic(err) } } Version Eingeführt in go-mail v0.3.9 WithDebugLog aktiviert die Debug-Protokollierung des SMTP-Verkehrs auf dem Client. Wenn aktiviert, wird jede SMTP-Kommunikation vom Client zum Server und umgekehrt in os.Stderr protokolliert.\nIn der Ausgabe steht C --\u0026gt; S für die Kommunikation vom Client zum Server und C \u0026lt;-- S für die Kommunikation zurück vom Server zum Client.\nHier ist ein Beispiel für die Ausgabe:\n2023/01/15 20:21:18 [DEBUG] C --\u0026gt; S: EHLO client.example.com 2023/01/15 20:21:18 [DEBUG] C \u0026lt;-- S: 250 server.example.com PIPELINING SIZE 152428800 ETRN STARTTLS AUTH LOGIN PLAIN AUTH=LOGIN PLAIN ENHANCEDSTATUSCODES 8BITMIME DSN 2023/01/15 20:21:18 [DEBUG] C --\u0026gt; S: STARTTLS 2023/01/15 20:21:18 [DEBUG] C \u0026lt;-- S: 220 2.0.0 Ready to start TLS 2023/01/15 20:21:18 [DEBUG] C --\u0026gt; S: EHLO client.example.com 2023/01/15 20:21:18 [DEBUG] C \u0026lt;-- S: 250 server.example.com PIPELINING SIZE 152428800 ETRN AUTH LOGIN PLAIN AUTH=LOGIN PLAIN ENHANCEDSTATUSCODES 8BITMIME DSN 2023/01/15 20:21:18 [DEBUG] C --\u0026gt; S: AUTH LOGIN 2023/01/15 20:21:18 [DEBUG] C \u0026lt;-- S: 334 VXNlcm5hbWU6 2023/01/15 20:21:18 [DEBUG] C --\u0026gt; S: 2023/01/15 20:21:20 [DEBUG] C \u0026lt;-- S: 535 5.7.8 Error: authentication failed: VXNlcm5hbWU6 WithDSN() Signature 1 func WithDSN() Option Example 1 2 3 4 5 6 7 8 9 10 package main import \u0026#34;github.com/wneessen/go-mail\u0026#34; func main() { c, err := mail.NewClient(\u0026#34;mail.example.com\u0026#34;, mail.WithDSN()) if err != nil { panic(err) } } Die WithDSN Optionsfunktion weist den Client an, DSNs anzufordern (wenn der Server sie unterstützt), wie in RFC 1891 beschrieben.\nDSNs (Delivery Status Notification) sind eine Erweiterung des SMTP-Protokolls und müssen von dem sendenden Server unterstützt werden. Der RFC für DSNs definiert verschiedene Parameter, von denen wir einmal die implementiert haben, die wir für go-mail für am sinnvollsten halten:\nDie RET-Erweiterung für den MAIL FROM-Befehl, damit der Benutzer angeben kann, ob ein DSN die vollständige Mail (FULL) oder nur die Kopfzeilen (HDRS) der gesendeten Mail enthalten soll. Die NOTIFY-Erweiterung, die es dem Benutzer ermöglicht, einen DSN für die verschiedenen Arten von erlaubten Situationen anzufordern: NEVER, SUCCESS, FAILURE und DELAY ENVID und ORCPT werden derzeit nicht unterstützt, könnten aber in einer späteren Version folgen (bitte eröffne ein Issue, wenn du darin einen Nutzen siehst).\nStandardmäßig setzt WithDSN() die FULL Mail From Return Option und die SUCCESS und FAILURE Recipient Notify Optionen. Wenn du andere Einstellungen für den DSN verwenden möchtest, lies bitte die Dokumentation für WithDSNMailReturnType und WithDSNRcptNotifyType\nWithDSNMailReturnType() Signature 1 func WithDSNMailReturnType(DSNMailReturnOption) Option Example 1 2 3 4 5 6 7 8 9 10 package main import \u0026#34;github.com/wneessen/go-mail\u0026#34; func main() { c, err := mail.NewClient(\u0026#34;mail.example.com\u0026#34;, mail.WithDSNMailReturnType(mail.DSNMailReturnFull)) if err != nil { panic(err) } } WithDSNMailReturnType ermöglicht es dem Client, DSNs anzufordern (wenn der Server es unterstützt), wie in der RFC 1891 beschrieben und den MAIL FROM Rückgabeoptionstyp auf die angegebene DSNMailReturnOption\ngo-mail hat die folgenden zwei DSNMailReturnOption Typen bereits eingebaut:\nDSNMailReturnHeadersOnly: verlangt, dass nur die Kopfzeilen der Nachricht zurückgegeben werden. Siehe: RFC 1891, Abschnitt 5.3 DSNMailReturnFull: fordert an, dass die gesamte Nachricht in jeder \u0026ldquo;fehlgeschlagenen\u0026rdquo; Zustellungsstatus-Benachrichtigung, die für diesen Empfänger ausgegeben wird, zurückgegeben wird Siehe: RFC 1891, Abschnitt 5.3 WithDSNRcptNotifyType() Signature 1 func WithDSNRcptNotifyType(...DSNRcptNotifyOption) Option Example 1 2 3 4 5 6 7 8 9 10 11 12 package main import \u0026#34;github.com/wneessen/go-mail\u0026#34; func main() { c, err := mail.NewClient(\u0026#34;mail.example.com\u0026#34;, mail.WithDSNRcptNotifyType(mail.DSNRcptNotifyFailure, mail.DSNRcptNotifyDelay, mail.DSNRcptNotifySuccess)) if err != nil { panic(err) } } WithDSNRcptNotifyType ermöglicht dem Client, DSNs wie in RFC 1891 beschrieben anzufordern und setzt die RCPT TO Notify-Optionen auf die angegebene Liste von DSNRcptNotifyOption\ngo-mail hat die folgenden DSNRcptNotifyOption Typen bereits eingebaut:\nDSNRcptNotifyNever: fordert, dass ein DSN unter keinen Umständen an den Absender zurückgeschickt wird. Siehe: RFC 1891, Abschnitt 5.1 DSNRcptNotifySuccess: fordert an, dass ein DSN bei erfolgreicher Übergabe ausgegeben wird Siehe: RFC 1891, Abschnitt 5.1 DSNRcptNotifyFailure: fordert an, dass ein DSN bei Zustellungsfehler ausgegeben wird Siehe: RFC 1891, Abschnitt 5.1 DSNRcptNotifyDelay: gibt die Bereitschaft des Senders an, \u0026ldquo;verzögerte\u0026rdquo; DSNs zu empfangen. Verspätete DSNs können ausgestellt werden, wenn sich die Zustellung einer Nachricht um eine ungewöhnliche Zeitspanne verzögert hat (wie vom MTA bestimmt, bei dem die Nachricht verzögert wurde), aber der endgültige Zustellungsstatus (ob erfolgreich oder nicht) nicht ermittelt werden kann. Das Fehlen des Schlüsselworts DELAY in einem NOTIFY-Parameter bedeutet, dass unter keinen Umständen ein \u0026ldquo;verzögerter\u0026rdquo; DSN ausgegeben werden darf. Siehe: RFC 1891, Abschnitt 5.1 WithHELO() Signature 1 func WithHELO(string) Option Example 1 2 3 4 5 6 7 8 9 10 package main import \u0026#34;github.com/wneessen/go-mail\u0026#34; func main() { c, err := mail.NewClient(\u0026#34;mail.example.com\u0026#34;, mail.WithHELO(\u0026#34;test.example.com\u0026#34;)) if err != nil { panic(err) } } WithHELO weist den Client an, die angegebene Zeichenkette als HELO/EHLO Begrüßungshost zu verwenden. Standardmäßig verwendet der Client die Methode os.Hostname() von Go, um den lokalen Hostnamen zu ermitteln und diesen für die HELO/EHLO-Begrüßung zu verwenden. WithHELO wird dies außer Kraft setzen.\n"},{"id":6,"href":"/de/community/","title":"Communities","parent":"Willkommen in der go-mail-Dokumentation","content":""},{"id":7,"href":"/de/community/guide/","title":"Community-Leitfaden","parent":"Communities","content":"Die go-mail-Community wächst und wenn Du dies liest, stehen die Chancen gut, dass Du auch mitmachen willst!\nRessourcen Verhaltenskodex Support- und Ankündigungskanäle Mitwirken Entwicklung neuer Funktionen Fehler beheben Testen Dokumentation Übersetzungen Unterstützen Ressourcen Verhaltenskodex In unserer Community folgen wir dem Verhaltenskodex und verlangen von jedem, der Teilnehmen möchte, sich ebenso zu verhalten.\nSupport- und Ankündigungskanäle Mastodon: Folge uns auf Mastodon, um aktuelle Nachrichten über go-mail zu erhalten go-mail Forum: Erhalte Ankündigungen und starte Diskussionen über go-mail. Github Tickets: Wenn Du einen Bug melden oder ein Feature vorschlagen möchtest, benutze bitte die Github \u0026ldquo;Issues\u0026rdquo; Funktion. Bitte beachte die Regeln, die in jedem Projektarchiv-Template angegeben sind. Discord: Ein Ort, an dem sich Go-Mail-Entwickler und -Benutzer treffen und in Echtzeit chatten können. Mitwirken go-mail ist ein Open-Source-Projekt, das von der Community betrieben wird. Wir begrüßen jeden, der mit uns an diesem Projekt mitwirkt. Diese Dokumentation richtet sich an alle, die sich mit dem Projekt und den Entwicklungsprozessen vertraut machen möchten.\nEntwicklung neuer Funktionen Fehler beheben Testen Dokumentation Übersetzungen Unterstützen Entwicklung neuer Funktionen Wir sind immer daran interessiert, Funktionen zu go-mail hinzuzufügen. Der Prozess zum Hinzufügen neuer Funktionen lautet wie folgt:\nSchau im Issue-Bereich auf Github nach verfügbaren Issues mit dem Tag \u0026ldquo;TODO\u0026rdquo; oder \u0026ldquo;help wanted\u0026rdquo; Wenn kein offenes \u0026ldquo;TODO\u0026rdquo;/\u0026ldquo;Hilfe gesucht\u0026rdquo;-Thema gefunden wird oder die Funktion, die du im Sinn hast, nicht abgedeckt ist, mach bitte ein Issue für diese spezielle Funktion auf und warte auf das \u0026ldquo;OK\u0026rdquo; der Maintainers Überprüfe vor der Entwicklung, ob die Ausgabe die folgenden Informationen enthält: Der Zweck der Erweiterung Was für die Verbesserung nicht in Frage kommt Wenn das Issue diese Informationen nicht enthält, kannst du sie bei der Person, die das Issue eröffnet hat, anfordern. Manchmal werden Platzhalterausgaben erstellt und erfordern mehr Details Kommentiere das Thema und gib an, ob du die Funktion entwickeln möchtest Klone das Repository und erstelle einen Zweig mit dem Format feature/\u0026lt;issue_number\u0026gt;_\u0026lt;issue_title\u0026gt; Neue Funktionen erfordern oft eine Dokumentation, also stelle bitte sicher, dass du die Dokumentation als Teil der Änderungen auch hinzugefügt oder aktualisiert hast Bitte stelle sicher, dass dein Code die erforderliche Testabdeckung hat Sobald die Funktion zum Testen bereit ist, erstellst du einen PR-Entwurf. Bitte stelle sicher, dass in der PR-Beschreibung die Testszenarien und Testfälle mit Häkchen aufgeführt sind, damit andere wissen, was noch getestet werden muss Sobald alle Tests abgeschlossen sind, aktualisiere bitte den Status des PR von Entwurf und hinterlasse eine Nachricht Alle PRs, die ohne eine entsprechende Ausgabe eröffnet werden, können abgelehnt werden. Fehler beheben Das Verfahren zur Behebung von Fehlern ist wie folgt:\nÜberprüfe die Github Issues und wähle einen Fehler zum Beheben aus Überprüfe vor der Entwicklung, ob das Issue die folgenden Informationen enthält: Der Umfang des Problems einschließlich der betroffenen Plattformen Die Schritte zum Reproduzieren. Manchmal werden Bugs geöffnet, die keine go-mail Probleme sind, und der Berichterstatter muss anhand eines minimalen, reproduzierbaren Beispiels beweisen, dass es sich um ein go-mail Problem handelt Wenn das Problem diese Informationen nicht enthält, kannst du sie bei der Person, die das Problem eröffnet hat, anfordern Kommentiere das Issue und gib an, dass du eine Lösung entwickeln möchtest Klone das Repository und erstelle einen Branch mit dem Format bugfix/\u0026lt;issue_number\u0026gt;_\u0026lt;issue_title\u0026gt; Sobald die Korrektur zum Testen bereit ist, erstellst du einen PR-Entwurf. Bitte stelle sicher, dass in der PR-Beschreibung die Testszenarien und Testfälle mit Häkchen aufgeführt sind, damit andere wissen, was noch getestet werden muss Sobald alle Tests abgeschlossen sind, aktualisiere bitte den Status des PR von Entwurf und hinterlasse eine Nachricht. Es hält dich nichts davon ab, ein Issue zu öffnen und selbst daran zu arbeiten, aber sei dir bitte bewusst, dass alle Fehlerbehebungen besprochen werden sollten, da der Ansatz unbeabsichtigte Nebenwirkungen haben kann. Alle PRs, die ohne eine entsprechende Ausgabe eröffnet werden, können abgelehnt werden. Testen Das Testen ist von entscheidender Bedeutung, um die Qualität des Projekts sicherzustellen. Es gibt ein paar Szenarien, in denen das Testen dem Projekt wirklich helfen kann:\nTesten, ob ein Fehler auf deinem lokalen System reproduzierbar ist PRs testen, um sicherzustellen, dass sie richtig funktionieren Wenn du testen möchtest, ob die Fehlermeldung eines anderen Nutzers auf deinem System reproduzierbar ist, kannst du einen Kommentar zu der Meldung hinzufügen, der dies mit der Ausgabe deines Testprogramms bestätigt.\nUm PRs zu testen, wählst du einen PR zum Testen aus und überprüfst, ob in der PR-Beschreibung die Testszenarien aufgeführt sind. Wenn nicht, bitte die Person, die den PR eröffnet hat, diese Liste zur Verfügung zu stellen. Wenn du ein gültiges Testszenario ermittelt hast, melde deine Ergebnisse bitte in der PR.\nWenn du jemals mehr Klarheit oder Hilfe beim Testen brauchst, stelle bitte eine Frage im Github Forum oder auf Discord.\nDokumentation Während wir eine ordentliche GoDoc-Dokumentation mit Kommentaren im Code verlangen, ist diese Website für eine ausführlichere Dokumentation der Funktionen und des Projekts selbst gedacht.\nDa das Thema \u0026ldquo;Dokumentation\u0026rdquo; immer schwierig ist und die Website noch unvollständig ist, ist jeder Beitrag dazu sehr willkommen. Funktionen ohne Dokumentation gelten für das Projekt als \u0026ldquo;unvollendet\u0026rdquo;, sie sind genauso wichtig wie der Code.\nDie Website wurde mit Hugo und dem Geekdocs-Theme erstellt. Es ist sehr einfach und besteht im Wesentlichen aus Markdown-Dateien. Im Repository der Website findest du eine Anleitung, wie du die Website auf deinem lokalen Computer installieren kannst.\nÜbersetzungen Die Standarddokumente des go-mail-Projekts sind englische Dokumente. Wir verwenden das Tool \u0026ldquo;Crowdin\u0026rdquo;, um Dokumente in andere Sprachen zu übersetzen und sie mit der Website zu synchronisieren. Du kannst unserem Projekt beitreten und deine Übersetzungen einreichen, um einen Beitrag zu leisten.\nDerzeit ist die einzige unterstützte zweite Sprache Deutsch, aber wir sind daran interessiert, auch andere Sprachen hinzuzufügen. Bitte beantrage sie über ein Github-Problem im go-mail-website Repository.\nUnterstützen Eine gute Möglichkeit, zum Projekt beizutragen, ist es, anderen zu helfen, die Schwierigkeiten haben. Dies wird normalerweise als Problem oder als Nachricht auf dem #go-mail Discord-Kanal gemeldet. Schon die Klärung des Problems kann sehr hilfreich sein. Manchmal, wenn ein Problem diskutiert und gelöst wird, erstellen wir daraus einen Leitfaden, um anderen zu helfen, die mit den gleichen Problemen konfrontiert sind.\n"},{"id":8,"href":"/de/reference/client/","title":"Der Client für die Mailzustellung","parent":"Referenz","content":"In go-mail ist der Client für die Mailzustellung mit entfernten Mailservern zuständig, die über das SMTP-Protokoll kommunizieren.\nNewClient() Client Close() DialAndSend() DialAndSendWithContext() NewClient() Signature 1 func NewClient(string, ...Option) (*Client, error) Example 1 2 3 4 5 6 7 8 9 10 package main import \u0026#34;github.com/wneessen/go-mail\u0026#34; func main() { c, err := mail.NewClient(\u0026#34;mail.example.com\u0026#34;) if err != nil { panic(err) } } Um einen neuen Client zu erstellen, kannst du die Methode NewClient() verwenden. Als erstes Argument benötigt er den Hostnamen des sendenden SMTP-Servers. Optional kannst du eine Liste von Option-Funktionen angeben. Diese Optionsfunktionen können verwendet werden, um die Standardeinstellungen des Client zu überschreiben.\nIn der Optionen Dokumentation findest du ausführliche Informationen zu allen verfügbaren Optionen.\nClient Signature 1 2 3 type Client struct { // contains filtered or unexported fields } Close() Signature 1 func (*Client) Close() error Example 1 2 3 4 5 6 7 8 9 10 11 package main import \u0026#34;github.com/wneessen/go-mail\u0026#34; func main() { c, err := mail.NewClient(\u0026#34;mail.example.com\u0026#34;) if err != nil { panic(err) } defer c.Close() } Close() schließt die Verbindung zu dem SMTP-Server, mit dem der Client verbunden ist. Sie gibt einen error zurück, wenn der Client keine aktive Verbindung hat oder wenn das Schließen der Verbindung fehlschlägt.\nDialAndSend() Signature 1 func (*Client) DialAndSend(...*Msg) error Example 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 package main import \u0026#34;github.com/wneessen/go-mail\u0026#34; func main() { from := \u0026#34;Toni Tester \u0026lt;toni@example.com\u0026gt;\u0026#34; to := \u0026#34;Alice \u0026lt;alice@example.com\u0026gt;\u0026#34; server := \u0026#34;mail.example.com\u0026#34; m := mail.NewMsg() if err := m.From(from); err != nil { panic(err) } if err := m.To(to); err != nil { panic(err) } m.Subject(\u0026#34;This is a great subject\u0026#34;) c, err := mail.NewClient(server) if err != nil { panic(err) } if err := c.DialAndSend(m); err != nil { panic(err) } } Die Methode DialAndSend() ist ein Alias für DialAndSendWithContext() mit einem Standardkontext context.Background. DialAndSend() nimmt eine Liste von Msg Pointern als Argument(e) und gibt einen error zurück, wenn eine der durchgeführten Aktionen fehlschlägt.\nDialAndSendWithContext() Signature 1 func (*Client) DialAndSendWithContext(context.Context, ...*Msg) error Example 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 package main import \u0026#34;github.com/wneessen/go-mail\u0026#34; func main() { from := \u0026#34;Toni Tester \u0026lt;toni@example.com\u0026gt;\u0026#34; to := \u0026#34;Alice \u0026lt;alice@example.com\u0026gt;\u0026#34; server := \u0026#34;mail.example.com\u0026#34; m := mail.NewMsg() if err := m.From(from); err != nil { panic(err) } if err := m.To(to); err != nil { panic(err) } m.Subject(\u0026#34;This is a great subject\u0026#34;) c, err := mail.NewClient(server) if err != nil { panic(err) } ctx := context.Background() if err := c.DialAndSendWithContext(ctx, m); err != nil { panic(err) } } Die WählenUndSendenMitKontext() ist eine Abkürzungsmethode für den Client. Sobald der Client erstellt ist, wird er sich durch den Aufruf der Methode DialAndSendWithContext() mit dem konfigurierten Server verbinden, die angegebene Mail Msg verschicken und zum Schluss die Verbindung wieder schließen.\nDas erste Argument der Methode ist ein context.Context, gefolgt von einer Liste von einem oder mehreren Msg Pointern. DialAndSendWithContext() gibt einen error zurück, wenn eine der durchgeführten Aktionen fehlschlägt.\n"},{"id":9,"href":"/de/examples/simple-mailer/","title":"Einfaches Mailer-Beispiel","parent":"Beispiele","content":"Dieses Beispiel ist der simpelste Code, der erforderlich ist, um eine E-Mail mit go-mail erfolgreich zu versenden.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 package main import ( \u0026#34;log\u0026#34; \u0026#34;os\u0026#34; \u0026#34;github.com/wneessen/go-mail\u0026#34; ) func main() { msg := mail.NewMsg() if err := msg.From(\u0026#34;toni@tester.com\u0026#34;); err != nil { log.Fatalf(\u0026#34;failed to set FROM address: %s\u0026#34;, err) } if err := msg.To(\u0026#34;tina@recipient.org\u0026#34;); err != nil { log.Fatalf(\u0026#34;failed to set TO address: %s\u0026#34;, err) } msg.Subject(\u0026#34;This is my first test mail with go-mail!\u0026#34;) msg.SetBodyString(mail.TypeTextPlain, \u0026#34;This will be the content of the mail.\u0026#34;) // Deliver the mails via SMTP c, err := mail.NewClient(\u0026#34;smtp.example.com\u0026#34;, mail.WithSMTPAuth(mail.SMTPAuthPlain), mail.WithTLSPortPolicy(mail.TLSMandatory), mail.WithUsername(os.Getenv(\u0026#34;SMTP_USER\u0026#34;)), mail.WithPassword(os.Getenv(\u0026#34;SMTP_PASS\u0026#34;)), ) if err != nil { log.Fatalf(\u0026#34;failed to create new mail delivery client: %s\u0026#34;, err) } if err := c.DialAndSend(msg); err != nil { log.Fatalf(\u0026#34;failed to deliver mail: %s\u0026#34;, err) } log.Printf(\u0026#34;Test mail successfully delivered.\u0026#34;) } In diesem Beispiel wird eine einfache Test-Mail von toni@tester.com an tina@recipient.org gesendet.\nZunächst erstellen wir in Zeile 11 eine neue Msg. Der Typ Msg enthält alles, was für für deine Mailnachricht. Stell dir das wie eine neue Mail in deinem Mail-Benutzer-Agent vor. Der Typ Msg stellt dir alle Methoden zur Verfügung, die du zur Vorbereitung und Formatierung deiner Mailnachricht benötigst.\nIn Zeile 12 bis 14 legen wir die Absenderadresse fest. In diesem Fall ist es toni@tester.com. Da go-mail unter der Haube eine Menge Validierungen durchführt, stellt es sicher, dass die angegebene Mailadresse gültig ist. Deshalb prüfen wir den zurückgegebenen Fehler. In Zeile 15 bis 17 machen wir das Gleiche dasselbe für die Empfängeradresse. Die E-Mail wird an tina@recipient.org gesendet.\nAls Nächstes legen wir in Zeile 18 den Betreff für unsere E-Mail-Nachricht fest. Gefolgt vom Setzen einer einfachen Zeichenfolge als Nachrichtentext in Zeile 19. Das erste Argument für Msg.SetBodyString() ist ein MIME Content Type. In diesem Fall verwenden wir mail.TypeTextPlain für den Mailbody - also einen einfachen plain/text Mailbody.\nJetzt, wo unsere einfache E-Mail-Nachricht für den Versand vorbereitet ist, können wir einen \u0026ldquo;Client\u0026rdquo; erstellen. Der Client in go-mail verwaltet die Verbindung zu einem Mailserver und alles, was damit zusammenhängt. In Zeile 22 bis 25 initialisieren wir einen neuen Client-Typ und geben ihm einige Optionen. Das erste Argument ist der Mailserver, mit dem wir uns verbinden wollen. In unserem Beispiel ist es smtp.example.com. Dann teilen wir dem Client mit dass wir die SMTP-Authentifizierung über die Auth-Methode \u0026ldquo;PLAIN\u0026rdquo; durchführen müssen. Die Option mail.WithSMTPAuth(mail.SMTPAuthPlain) Option übernimmt dies. Mit der Option mail.WithTLSPortPolicy(mail.TLSMandatory) teilen wir dem Client dass wir eine TLS-Verbindung für den Versand unserer Mails benötigen. Wir setzen ihn auf den Zwangsmodus, so dass der Client die Verarbeitung abbricht, wenn er keine TLS-gesicherte Verbindung herstellen kann. Mit den Optionen mail.WithUsername() und mail.WithPassword() teilen wir dem Client mit, welchen Benutzernamen und welches Passwort er für die SMTP-Authentifizierung. Zeilen 26-28 prüfe, ob der Client-Aufruf ohne Fehler funktioniert hat.\nZum Schluss, in Zeile 29-32, senden wir unsere Mail-Nachricht mit unserem Mail-Client mit der Methode Client.DialAndSend(). Bei Erfolg wird eine kurze Nachricht ausgegeben oder ein Fehler gemeldet, wenn die Zustellung fehlgeschlagen ist.\n"},{"id":10,"href":"/de/community/merch/","title":"Merchandising","parent":"Communities","content":"Dank unserer wunderbaren Freunde von HelloTux können wir großartiges Go-Mail-Merchandising anbieten. Alle Merchandising-Artikel sind bestickt, um die bestmögliche und langlebige Qualität zu gewährleisten.\nWenn Sie die Open-Source-Community unterstützen und Deine Lieblings-Go-Mail-Bibliothek mit einem coolen Drip repräsentieren möchten, besuchen Sie unseren Merch-Shop unter: https://www.hellotux.com/go-mail.\n"},{"id":11,"href":"/de/security/","title":"Sicherheitsrichtlinie","parent":"Willkommen in der go-mail-Dokumentation","content":" Bekannte Schwachstellen Auch wenn es keine bekannte Sicherheitslücke in go-mail gibt, kannst du jederzeit auf der Sicherheitshinweise Seite von unseres GitHub-Projekts.\nEine Sicherheitslücke melden Um (mögliche) Sicherheitsprobleme in go-mail zu melden, sende bitte entweder eine Mail an security@go-mail.dev oder nutze die Github private Meldefunktion. Meldungen sind immer willkommen. Auch wenn du dir nicht 100%ig sicher bist, dass ein bestimmtes Problem, das du als Sicherheitsproblem einzustufen ist, würden wir gerne die Details hören, damit wir gemeinsam herausfinden können, ob das betreffende Problem behoben werden muss.\nIn der Regel erhältst du innerhalb eines Tages oder sogar innerhalb weniger Stunden eine Antwort.\nEnde-zu-Ende-Verschlüsselung Du kannst OpenPGP/GPG-verschlüsselte Mails an die Adresse security@go-mail.dev senden.\nÖffentlicher OpenPGP/GPG-Schlüssel:\n-----BEGIN PGP PUBLIC KEY BLOCK----- xjMEY8RwPBYJKwYBBAHaRw8BAQdAiLsW7pv+CCMq5Ol0hbIB1HnJI97u3zJw Wslr7GJzgOzNK3NlY3VyaXR5QGdvLW1haWwuZGV2IDxzZWN1cml0eUBnby1t YWlsLmRldj7CjAQQFgoAPgUCY8RwPAQLCQcICRCgTBOxf8keAAMVCAoEFgAC AQIZAQIbAwIeARYhBAoWEB7Y0bE7zcIOuaBME7F/yR4AAAByugD9HabWXsyD aPIDrIS97OBA1OLltB4NPT5ba9whKRxTEmMBALBiB2ML4ZTrjLqI6UbGkhJq mWeMtvmU0chZT7WNBO0PzjgEY8RwPBIKKwYBBAGXVQEFAQEHQGDEccz6gvl5 t8cMMb/Dy2l0elRZL+Nd0gOhnbWMWlArAwEIB8J4BBgWCAAqBQJjxHA8CRCg TBOxf8keAAIbDBYhBAoWEB7Y0bE7zcIOuaBME7F/yR4AAADaMwD9EvEA3NSN NtdSaeL/euh6oRRiCjKzh5bIqZiQXqMlIOoBAJvPE2facs8MISwTtDoHW0sD WdOs3yBpGlGCs5WEqvQH=zn96 -----END PGP PUBLIC KEY BLOCK----- "},{"id":12,"href":"/de/tags/","title":"Tags","parent":"Willkommen in der go-mail-Dokumentation","content":""},{"id":13,"href":"/de/","title":"Willkommen in der go-mail-Dokumentation","parent":"","content":" go-mail ist eine einfach zu benutzende Go-Bibliothek zum Formatieren und Versenden von E-Mails. Es verwerndet einen idomatischen Go-Stil und folgt \u0026ldquo;Best Practices\u0026rdquo; mit vernünftigen Standards. Die Bibliothek hängt nur von der Go-Standardbibliothek ab.\ngo-mail funktioniert wie ein programmatischer E-Mail-Client und bietet viele Methoden und Funktionalitäten, die Du als Standard in einem E-Mail-Programm betrachten würdest.\nErste Schritte mit go-mail Funktions-Highlights Nur abhängig von der Standard-Bibliothek go-mail benötigt keine Module von Drittanbietern und basiert ausschließlich auf der Go-Standardbibliothek\nModern, idiomatisch Wir verwenden moderne und idiotmatische Go-Standards mit dieser Bibliothek und folgen den modernsten bewährten -Verfahren mit vernünftigen Standardeinstellungen\nVollständiger TLS-Support go-mail unterstützt implizite STARTTLS mit verschiedenen Richtlinien sowie explizite SSL/TLS für Verbindungen zum Senden von Mail-Servern\nKontexte Wir verwenden Go-Kontexte für einen besseren Kontrollfluss und die Handhabung von Timeouts/Abbrüchen\nSMTP-Authentifizierung Unterstützung für drei gängige SMTP-Authentifizierungsmechanismen (LOGIN, PLAIN, CRAM-MD5) sowie für benutzerdefinierte Authentifizierungen.\nÜberprüfung von E-Mail-Adressen go-mail folgt RFC5322 und validiert die angegebenen Mailadressen\nUnterstützung allgemeiner Mail-Header go-mail bringt Generatoren für viele gängige Mail-Header mit (Message-ID, Datum, Bulk-Precedence, Priority, etc.)\nWiederverwendung von Verbindungen Du kannst mehrere Mails über dieselbe SMTP-Verbindung senden\nAnhänge/Einbettungen Volle Unterstützung für Anhänge und Inline-Einbettungen aus verschiedenen Quellen (lokales Dateisystem, io.Reader oder embed.FS)\nKodierungen und Inhaltsarten go-mail unterstützt standardmäßig verschiedene Kodierungen und Inhaltstypen\nMiddlewares Middleware-Unterstützung für Bibliotheken von Drittanbietern, um E-Mail-Nachrichten an ihre Bedürfnisse anzupassen\nSendmail und Dateispeicherung Unterstützung für den Versand von E-Mail-Nachrichten über eine lokale sendmail-Installation sowie die Ausgabe in lokale Dateien (z. B. als .eml-Dateien auf der Festplatte, um sie in einem MUA zu öffnen)\nMDNs und DSNs go-mail bietet Unterstützung für die Abfrage von MDNs (RFC 8098) und DSNs (RFC 1891)\nTemplate-Unterstützung Unterstützung für Go\u0026rsquo;s html/template und text/template (als Nachrichtentext, alternativer Teil oder Anhang/Embedded)\nDKIM Unterstützung DKIM-Signatur-Unterstützung über die go-mail-middlware/dkim Middleware\nDebug-Logging Unterstützung für den SMTP-Client, um jede SMTP-Kommunikation zu Debug-Zwecken in STDERR zu protokollieren\nBenutzerdefinierte Zustellungsfehler Mit dem Typ SendError kann der Benutzer detaillierte Informationen über Zustellungsfehler erhalten einschließlich der Angabe, ob der Fehler vorübergehender Natur ist oder nicht\nUnterstützung Wir haben einen Support- und allgemeinen Diskussionskanal auf Discord. Find us at: #go-mail\n"}]